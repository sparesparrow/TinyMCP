// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MCP_MCP_H_
#define FLATBUFFERS_GENERATED_MCP_MCP_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace mcp {

struct Annotations;
struct AnnotationsBuilder;

struct Error;
struct ErrorBuilder;

struct Ping;
struct PingBuilder;

struct Pong;
struct PongBuilder;

struct Request;
struct RequestBuilder;

struct Response;
struct ResponseBuilder;

struct Notification;
struct NotificationBuilder;

struct Tool;
struct ToolBuilder;

struct ToolCall;
struct ToolCallBuilder;

struct TextContent;
struct TextContentBuilder;

struct ImageContent;
struct ImageContentBuilder;

struct AudioContent;
struct AudioContentBuilder;

struct VideoContent;
struct VideoContentBuilder;

struct BlobContent;
struct BlobContentBuilder;

struct ToolResult;
struct ToolResultBuilder;

struct Resource;
struct ResourceBuilder;

struct ResourceContents;
struct ResourceContentsBuilder;

struct BlobResourceContents;
struct BlobResourceContentsBuilder;

struct PromptArgument;
struct PromptArgumentBuilder;

struct Prompt;
struct PromptBuilder;

struct Session;
struct SessionBuilder;

struct TransportConfig;
struct TransportConfigBuilder;

struct ServerCapabilities;
struct ServerCapabilitiesBuilder;

struct ClientCapabilities;
struct ClientCapabilitiesBuilder;

struct InitializeRequest;
struct InitializeRequestBuilder;

struct InitializeResponse;
struct InitializeResponseBuilder;

struct PrimitiveSchemaDefinition;
struct PrimitiveSchemaDefinitionBuilder;

struct BooleanSchema;
struct BooleanSchemaBuilder;

struct NumberSchema;
struct NumberSchemaBuilder;

struct StringSchema;
struct StringSchemaBuilder;

struct EnumSchema;
struct EnumSchemaBuilder;

struct ProgressToken;
struct ProgressTokenBuilder;

struct RequestId;
struct RequestIdBuilder;

struct Cursor;
struct CursorBuilder;

struct ModelHint;
struct ModelHintBuilder;

struct ModelPreferences;
struct ModelPreferencesBuilder;

struct Result;
struct ResultBuilder;

struct EmptyResult;
struct EmptyResultBuilder;

struct JSONRPCError;
struct JSONRPCErrorBuilder;

struct JSONRPCRequest;
struct JSONRPCRequestBuilder;

struct JSONRPCResponse;
struct JSONRPCResponseBuilder;

struct JSONRPCNotification;
struct JSONRPCNotificationBuilder;

struct ContentBlock;
struct ContentBlockBuilder;

struct PromptMessage;
struct PromptMessageBuilder;

struct SamplingMessage;
struct SamplingMessageBuilder;

struct PromptReference;
struct PromptReferenceBuilder;

struct ResourceLink;
struct ResourceLinkBuilder;

struct EmbeddedResource;
struct EmbeddedResourceBuilder;

struct ResourceTemplate;
struct ResourceTemplateBuilder;

struct ResourceTemplateReference;
struct ResourceTemplateReferenceBuilder;

struct TextResourceContents;
struct TextResourceContentsBuilder;

struct ToolAnnotations;
struct ToolAnnotationsBuilder;

struct Implementation;
struct ImplementationBuilder;

struct CompleteRequest;
struct CompleteRequestBuilder;

struct CompleteResult;
struct CompleteResultBuilder;

struct ElicitRequest;
struct ElicitRequestBuilder;

struct ElicitResult;
struct ElicitResultBuilder;

struct InitializeResult;
struct InitializeResultBuilder;

struct SetLevelRequest;
struct SetLevelRequestBuilder;

struct PingRequest;
struct PingRequestBuilder;

struct GetPromptRequest;
struct GetPromptRequestBuilder;

struct GetPromptResult;
struct GetPromptResultBuilder;

struct ListPromptsRequest;
struct ListPromptsRequestBuilder;

struct ListPromptsResult;
struct ListPromptsResultBuilder;

struct ListResourcesRequest;
struct ListResourcesRequestBuilder;

struct ListResourcesResult;
struct ListResourcesResultBuilder;

struct ReadResourceRequest;
struct ReadResourceRequestBuilder;

struct ReadResourceResult;
struct ReadResourceResultBuilder;

struct SubscribeRequest;
struct SubscribeRequestBuilder;

struct ListResourceTemplatesRequest;
struct ListResourceTemplatesRequestBuilder;

struct ListResourceTemplatesResult;
struct ListResourceTemplatesResultBuilder;

struct UnsubscribeRequest;
struct UnsubscribeRequestBuilder;

struct RootEntry;
struct RootEntryBuilder;

struct ListRootsRequest;
struct ListRootsRequestBuilder;

struct ListRootsResult;
struct ListRootsResultBuilder;

struct CreateMessageRequest;
struct CreateMessageRequestBuilder;

struct CreateMessageResult;
struct CreateMessageResultBuilder;

struct CallToolRequest;
struct CallToolRequestBuilder;

struct CallToolResult;
struct CallToolResultBuilder;

struct ListToolsRequest;
struct ListToolsRequestBuilder;

struct ListToolsResult;
struct ListToolsResultBuilder;

struct CancelledNotification;
struct CancelledNotificationBuilder;

struct InitializedNotification;
struct InitializedNotificationBuilder;

struct LoggingMessageNotification;
struct LoggingMessageNotificationBuilder;

struct ProgressNotification;
struct ProgressNotificationBuilder;

struct PromptListChangedNotification;
struct PromptListChangedNotificationBuilder;

struct ResourceListChangedNotification;
struct ResourceListChangedNotificationBuilder;

struct ResourceUpdatedNotification;
struct ResourceUpdatedNotificationBuilder;

struct RootsListChangedNotification;
struct RootsListChangedNotificationBuilder;

struct ToolListChangedNotification;
struct ToolListChangedNotificationBuilder;

struct Root;
struct RootBuilder;

enum MessageType : int8_t {
  MessageType_Request = 0,
  MessageType_Response = 1,
  MessageType_Notification = 2,
  MessageType_MIN = MessageType_Request,
  MessageType_MAX = MessageType_Notification
};

inline const MessageType (&EnumValuesMessageType())[3] {
  static const MessageType values[] = {
    MessageType_Request,
    MessageType_Response,
    MessageType_Notification
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[4] = {
    "Request",
    "Response",
    "Notification",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  if (::flatbuffers::IsOutRange(e, MessageType_Request, MessageType_Notification)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageType()[index];
}

enum Role : int8_t {
  Role_User = 0,
  Role_Assistant = 1,
  Role_System = 2,
  Role_MIN = Role_User,
  Role_MAX = Role_System
};

inline const Role (&EnumValuesRole())[3] {
  static const Role values[] = {
    Role_User,
    Role_Assistant,
    Role_System
  };
  return values;
}

inline const char * const *EnumNamesRole() {
  static const char * const names[4] = {
    "User",
    "Assistant",
    "System",
    nullptr
  };
  return names;
}

inline const char *EnumNameRole(Role e) {
  if (::flatbuffers::IsOutRange(e, Role_User, Role_System)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRole()[index];
}

enum ToolCallStatus : int8_t {
  ToolCallStatus_Pending = 0,
  ToolCallStatus_InProgress = 1,
  ToolCallStatus_Completed = 2,
  ToolCallStatus_Failed = 3,
  ToolCallStatus_MIN = ToolCallStatus_Pending,
  ToolCallStatus_MAX = ToolCallStatus_Failed
};

inline const ToolCallStatus (&EnumValuesToolCallStatus())[4] {
  static const ToolCallStatus values[] = {
    ToolCallStatus_Pending,
    ToolCallStatus_InProgress,
    ToolCallStatus_Completed,
    ToolCallStatus_Failed
  };
  return values;
}

inline const char * const *EnumNamesToolCallStatus() {
  static const char * const names[5] = {
    "Pending",
    "InProgress",
    "Completed",
    "Failed",
    nullptr
  };
  return names;
}

inline const char *EnumNameToolCallStatus(ToolCallStatus e) {
  if (::flatbuffers::IsOutRange(e, ToolCallStatus_Pending, ToolCallStatus_Failed)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesToolCallStatus()[index];
}

enum ResourceType : int8_t {
  ResourceType_Text = 0,
  ResourceType_Image = 1,
  ResourceType_Audio = 2,
  ResourceType_Video = 3,
  ResourceType_Blob = 4,
  ResourceType_MIN = ResourceType_Text,
  ResourceType_MAX = ResourceType_Blob
};

inline const ResourceType (&EnumValuesResourceType())[5] {
  static const ResourceType values[] = {
    ResourceType_Text,
    ResourceType_Image,
    ResourceType_Audio,
    ResourceType_Video,
    ResourceType_Blob
  };
  return values;
}

inline const char * const *EnumNamesResourceType() {
  static const char * const names[6] = {
    "Text",
    "Image",
    "Audio",
    "Video",
    "Blob",
    nullptr
  };
  return names;
}

inline const char *EnumNameResourceType(ResourceType e) {
  if (::flatbuffers::IsOutRange(e, ResourceType_Text, ResourceType_Blob)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResourceType()[index];
}

enum Message : uint8_t {
  Message_NONE = 0,
  Message_Request = 1,
  Message_Response = 2,
  Message_Notification = 3,
  Message_MIN = Message_NONE,
  Message_MAX = Message_Notification
};

inline const Message (&EnumValuesMessage())[4] {
  static const Message values[] = {
    Message_NONE,
    Message_Request,
    Message_Response,
    Message_Notification
  };
  return values;
}

inline const char * const *EnumNamesMessage() {
  static const char * const names[5] = {
    "NONE",
    "Request",
    "Response",
    "Notification",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  if (::flatbuffers::IsOutRange(e, Message_NONE, Message_Notification)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template<> struct MessageTraits<mcp::Request> {
  static const Message enum_value = Message_Request;
};

template<> struct MessageTraits<mcp::Response> {
  static const Message enum_value = Message_Response;
};

template<> struct MessageTraits<mcp::Notification> {
  static const Message enum_value = Message_Notification;
};

bool VerifyMessage(::flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum Content : uint8_t {
  Content_NONE = 0,
  Content_TextContent = 1,
  Content_ImageContent = 2,
  Content_AudioContent = 3,
  Content_VideoContent = 4,
  Content_BlobContent = 5,
  Content_MIN = Content_NONE,
  Content_MAX = Content_BlobContent
};

inline const Content (&EnumValuesContent())[6] {
  static const Content values[] = {
    Content_NONE,
    Content_TextContent,
    Content_ImageContent,
    Content_AudioContent,
    Content_VideoContent,
    Content_BlobContent
  };
  return values;
}

inline const char * const *EnumNamesContent() {
  static const char * const names[7] = {
    "NONE",
    "TextContent",
    "ImageContent",
    "AudioContent",
    "VideoContent",
    "BlobContent",
    nullptr
  };
  return names;
}

inline const char *EnumNameContent(Content e) {
  if (::flatbuffers::IsOutRange(e, Content_NONE, Content_BlobContent)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesContent()[index];
}

template<typename T> struct ContentTraits {
  static const Content enum_value = Content_NONE;
};

template<> struct ContentTraits<mcp::TextContent> {
  static const Content enum_value = Content_TextContent;
};

template<> struct ContentTraits<mcp::ImageContent> {
  static const Content enum_value = Content_ImageContent;
};

template<> struct ContentTraits<mcp::AudioContent> {
  static const Content enum_value = Content_AudioContent;
};

template<> struct ContentTraits<mcp::VideoContent> {
  static const Content enum_value = Content_VideoContent;
};

template<> struct ContentTraits<mcp::BlobContent> {
  static const Content enum_value = Content_BlobContent;
};

bool VerifyContent(::flatbuffers::Verifier &verifier, const void *obj, Content type);
bool VerifyContentVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum LoggingLevel : int8_t {
  LoggingLevel_DEBUG = 0,
  LoggingLevel_INFO = 1,
  LoggingLevel_NOTICE = 2,
  LoggingLevel_WARNING = 3,
  LoggingLevel_ERROR = 4,
  LoggingLevel_CRITICAL = 5,
  LoggingLevel_ALERT = 6,
  LoggingLevel_EMERGENCY = 7,
  LoggingLevel_MIN = LoggingLevel_DEBUG,
  LoggingLevel_MAX = LoggingLevel_EMERGENCY
};

inline const LoggingLevel (&EnumValuesLoggingLevel())[8] {
  static const LoggingLevel values[] = {
    LoggingLevel_DEBUG,
    LoggingLevel_INFO,
    LoggingLevel_NOTICE,
    LoggingLevel_WARNING,
    LoggingLevel_ERROR,
    LoggingLevel_CRITICAL,
    LoggingLevel_ALERT,
    LoggingLevel_EMERGENCY
  };
  return values;
}

inline const char * const *EnumNamesLoggingLevel() {
  static const char * const names[9] = {
    "DEBUG",
    "INFO",
    "NOTICE",
    "WARNING",
    "ERROR",
    "CRITICAL",
    "ALERT",
    "EMERGENCY",
    nullptr
  };
  return names;
}

inline const char *EnumNameLoggingLevel(LoggingLevel e) {
  if (::flatbuffers::IsOutRange(e, LoggingLevel_DEBUG, LoggingLevel_EMERGENCY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLoggingLevel()[index];
}

enum RootMessage : uint8_t {
  RootMessage_NONE = 0,
  RootMessage_JSONRPCRequest = 1,
  RootMessage_JSONRPCResponse = 2,
  RootMessage_JSONRPCNotification = 3,
  RootMessage_InitializeRequest = 4,
  RootMessage_InitializeResponse = 5,
  RootMessage_InitializeResult = 6,
  RootMessage_Ping = 7,
  RootMessage_Pong = 8,
  RootMessage_PingRequest = 9,
  RootMessage_CompleteRequest = 10,
  RootMessage_CompleteResult = 11,
  RootMessage_ElicitRequest = 12,
  RootMessage_ElicitResult = 13,
  RootMessage_GetPromptRequest = 14,
  RootMessage_GetPromptResult = 15,
  RootMessage_ListPromptsRequest = 16,
  RootMessage_ListPromptsResult = 17,
  RootMessage_ListResourcesRequest = 18,
  RootMessage_ListResourcesResult = 19,
  RootMessage_ReadResourceRequest = 20,
  RootMessage_ReadResourceResult = 21,
  RootMessage_SubscribeRequest = 22,
  RootMessage_UnsubscribeRequest = 23,
  RootMessage_ListResourceTemplatesRequest = 24,
  RootMessage_ListResourceTemplatesResult = 25,
  RootMessage_ResourceUpdatedNotification = 26,
  RootMessage_ListRootsRequest = 27,
  RootMessage_ListRootsResult = 28,
  RootMessage_CreateMessageRequest = 29,
  RootMessage_CreateMessageResult = 30,
  RootMessage_CallToolRequest = 31,
  RootMessage_CallToolResult = 32,
  RootMessage_ListToolsRequest = 33,
  RootMessage_ListToolsResult = 34,
  RootMessage_ToolListChangedNotification = 35,
  RootMessage_SetLevelRequest = 36,
  RootMessage_LoggingMessageNotification = 37,
  RootMessage_CancelledNotification = 38,
  RootMessage_InitializedNotification = 39,
  RootMessage_ProgressNotification = 40,
  RootMessage_PromptListChangedNotification = 41,
  RootMessage_ResourceListChangedNotification = 42,
  RootMessage_RootsListChangedNotification = 43,
  RootMessage_MIN = RootMessage_NONE,
  RootMessage_MAX = RootMessage_RootsListChangedNotification
};

inline const RootMessage (&EnumValuesRootMessage())[44] {
  static const RootMessage values[] = {
    RootMessage_NONE,
    RootMessage_JSONRPCRequest,
    RootMessage_JSONRPCResponse,
    RootMessage_JSONRPCNotification,
    RootMessage_InitializeRequest,
    RootMessage_InitializeResponse,
    RootMessage_InitializeResult,
    RootMessage_Ping,
    RootMessage_Pong,
    RootMessage_PingRequest,
    RootMessage_CompleteRequest,
    RootMessage_CompleteResult,
    RootMessage_ElicitRequest,
    RootMessage_ElicitResult,
    RootMessage_GetPromptRequest,
    RootMessage_GetPromptResult,
    RootMessage_ListPromptsRequest,
    RootMessage_ListPromptsResult,
    RootMessage_ListResourcesRequest,
    RootMessage_ListResourcesResult,
    RootMessage_ReadResourceRequest,
    RootMessage_ReadResourceResult,
    RootMessage_SubscribeRequest,
    RootMessage_UnsubscribeRequest,
    RootMessage_ListResourceTemplatesRequest,
    RootMessage_ListResourceTemplatesResult,
    RootMessage_ResourceUpdatedNotification,
    RootMessage_ListRootsRequest,
    RootMessage_ListRootsResult,
    RootMessage_CreateMessageRequest,
    RootMessage_CreateMessageResult,
    RootMessage_CallToolRequest,
    RootMessage_CallToolResult,
    RootMessage_ListToolsRequest,
    RootMessage_ListToolsResult,
    RootMessage_ToolListChangedNotification,
    RootMessage_SetLevelRequest,
    RootMessage_LoggingMessageNotification,
    RootMessage_CancelledNotification,
    RootMessage_InitializedNotification,
    RootMessage_ProgressNotification,
    RootMessage_PromptListChangedNotification,
    RootMessage_ResourceListChangedNotification,
    RootMessage_RootsListChangedNotification
  };
  return values;
}

inline const char * const *EnumNamesRootMessage() {
  static const char * const names[45] = {
    "NONE",
    "JSONRPCRequest",
    "JSONRPCResponse",
    "JSONRPCNotification",
    "InitializeRequest",
    "InitializeResponse",
    "InitializeResult",
    "Ping",
    "Pong",
    "PingRequest",
    "CompleteRequest",
    "CompleteResult",
    "ElicitRequest",
    "ElicitResult",
    "GetPromptRequest",
    "GetPromptResult",
    "ListPromptsRequest",
    "ListPromptsResult",
    "ListResourcesRequest",
    "ListResourcesResult",
    "ReadResourceRequest",
    "ReadResourceResult",
    "SubscribeRequest",
    "UnsubscribeRequest",
    "ListResourceTemplatesRequest",
    "ListResourceTemplatesResult",
    "ResourceUpdatedNotification",
    "ListRootsRequest",
    "ListRootsResult",
    "CreateMessageRequest",
    "CreateMessageResult",
    "CallToolRequest",
    "CallToolResult",
    "ListToolsRequest",
    "ListToolsResult",
    "ToolListChangedNotification",
    "SetLevelRequest",
    "LoggingMessageNotification",
    "CancelledNotification",
    "InitializedNotification",
    "ProgressNotification",
    "PromptListChangedNotification",
    "ResourceListChangedNotification",
    "RootsListChangedNotification",
    nullptr
  };
  return names;
}

inline const char *EnumNameRootMessage(RootMessage e) {
  if (::flatbuffers::IsOutRange(e, RootMessage_NONE, RootMessage_RootsListChangedNotification)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRootMessage()[index];
}

template<typename T> struct RootMessageTraits {
  static const RootMessage enum_value = RootMessage_NONE;
};

template<> struct RootMessageTraits<mcp::JSONRPCRequest> {
  static const RootMessage enum_value = RootMessage_JSONRPCRequest;
};

template<> struct RootMessageTraits<mcp::JSONRPCResponse> {
  static const RootMessage enum_value = RootMessage_JSONRPCResponse;
};

template<> struct RootMessageTraits<mcp::JSONRPCNotification> {
  static const RootMessage enum_value = RootMessage_JSONRPCNotification;
};

template<> struct RootMessageTraits<mcp::InitializeRequest> {
  static const RootMessage enum_value = RootMessage_InitializeRequest;
};

template<> struct RootMessageTraits<mcp::InitializeResponse> {
  static const RootMessage enum_value = RootMessage_InitializeResponse;
};

template<> struct RootMessageTraits<mcp::InitializeResult> {
  static const RootMessage enum_value = RootMessage_InitializeResult;
};

template<> struct RootMessageTraits<mcp::Ping> {
  static const RootMessage enum_value = RootMessage_Ping;
};

template<> struct RootMessageTraits<mcp::Pong> {
  static const RootMessage enum_value = RootMessage_Pong;
};

template<> struct RootMessageTraits<mcp::PingRequest> {
  static const RootMessage enum_value = RootMessage_PingRequest;
};

template<> struct RootMessageTraits<mcp::CompleteRequest> {
  static const RootMessage enum_value = RootMessage_CompleteRequest;
};

template<> struct RootMessageTraits<mcp::CompleteResult> {
  static const RootMessage enum_value = RootMessage_CompleteResult;
};

template<> struct RootMessageTraits<mcp::ElicitRequest> {
  static const RootMessage enum_value = RootMessage_ElicitRequest;
};

template<> struct RootMessageTraits<mcp::ElicitResult> {
  static const RootMessage enum_value = RootMessage_ElicitResult;
};

template<> struct RootMessageTraits<mcp::GetPromptRequest> {
  static const RootMessage enum_value = RootMessage_GetPromptRequest;
};

template<> struct RootMessageTraits<mcp::GetPromptResult> {
  static const RootMessage enum_value = RootMessage_GetPromptResult;
};

template<> struct RootMessageTraits<mcp::ListPromptsRequest> {
  static const RootMessage enum_value = RootMessage_ListPromptsRequest;
};

template<> struct RootMessageTraits<mcp::ListPromptsResult> {
  static const RootMessage enum_value = RootMessage_ListPromptsResult;
};

template<> struct RootMessageTraits<mcp::ListResourcesRequest> {
  static const RootMessage enum_value = RootMessage_ListResourcesRequest;
};

template<> struct RootMessageTraits<mcp::ListResourcesResult> {
  static const RootMessage enum_value = RootMessage_ListResourcesResult;
};

template<> struct RootMessageTraits<mcp::ReadResourceRequest> {
  static const RootMessage enum_value = RootMessage_ReadResourceRequest;
};

template<> struct RootMessageTraits<mcp::ReadResourceResult> {
  static const RootMessage enum_value = RootMessage_ReadResourceResult;
};

template<> struct RootMessageTraits<mcp::SubscribeRequest> {
  static const RootMessage enum_value = RootMessage_SubscribeRequest;
};

template<> struct RootMessageTraits<mcp::UnsubscribeRequest> {
  static const RootMessage enum_value = RootMessage_UnsubscribeRequest;
};

template<> struct RootMessageTraits<mcp::ListResourceTemplatesRequest> {
  static const RootMessage enum_value = RootMessage_ListResourceTemplatesRequest;
};

template<> struct RootMessageTraits<mcp::ListResourceTemplatesResult> {
  static const RootMessage enum_value = RootMessage_ListResourceTemplatesResult;
};

template<> struct RootMessageTraits<mcp::ResourceUpdatedNotification> {
  static const RootMessage enum_value = RootMessage_ResourceUpdatedNotification;
};

template<> struct RootMessageTraits<mcp::ListRootsRequest> {
  static const RootMessage enum_value = RootMessage_ListRootsRequest;
};

template<> struct RootMessageTraits<mcp::ListRootsResult> {
  static const RootMessage enum_value = RootMessage_ListRootsResult;
};

template<> struct RootMessageTraits<mcp::CreateMessageRequest> {
  static const RootMessage enum_value = RootMessage_CreateMessageRequest;
};

template<> struct RootMessageTraits<mcp::CreateMessageResult> {
  static const RootMessage enum_value = RootMessage_CreateMessageResult;
};

template<> struct RootMessageTraits<mcp::CallToolRequest> {
  static const RootMessage enum_value = RootMessage_CallToolRequest;
};

template<> struct RootMessageTraits<mcp::CallToolResult> {
  static const RootMessage enum_value = RootMessage_CallToolResult;
};

template<> struct RootMessageTraits<mcp::ListToolsRequest> {
  static const RootMessage enum_value = RootMessage_ListToolsRequest;
};

template<> struct RootMessageTraits<mcp::ListToolsResult> {
  static const RootMessage enum_value = RootMessage_ListToolsResult;
};

template<> struct RootMessageTraits<mcp::ToolListChangedNotification> {
  static const RootMessage enum_value = RootMessage_ToolListChangedNotification;
};

template<> struct RootMessageTraits<mcp::SetLevelRequest> {
  static const RootMessage enum_value = RootMessage_SetLevelRequest;
};

template<> struct RootMessageTraits<mcp::LoggingMessageNotification> {
  static const RootMessage enum_value = RootMessage_LoggingMessageNotification;
};

template<> struct RootMessageTraits<mcp::CancelledNotification> {
  static const RootMessage enum_value = RootMessage_CancelledNotification;
};

template<> struct RootMessageTraits<mcp::InitializedNotification> {
  static const RootMessage enum_value = RootMessage_InitializedNotification;
};

template<> struct RootMessageTraits<mcp::ProgressNotification> {
  static const RootMessage enum_value = RootMessage_ProgressNotification;
};

template<> struct RootMessageTraits<mcp::PromptListChangedNotification> {
  static const RootMessage enum_value = RootMessage_PromptListChangedNotification;
};

template<> struct RootMessageTraits<mcp::ResourceListChangedNotification> {
  static const RootMessage enum_value = RootMessage_ResourceListChangedNotification;
};

template<> struct RootMessageTraits<mcp::RootsListChangedNotification> {
  static const RootMessage enum_value = RootMessage_RootsListChangedNotification;
};

bool VerifyRootMessage(::flatbuffers::Verifier &verifier, const void *obj, RootMessage type);
bool VerifyRootMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct Annotations FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnnotationsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AUDIENCE = 4,
    VT_LASTMODIFIED = 6,
    VT_PRIORITY = 8
  };
  const ::flatbuffers::Vector<int8_t> *audience() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_AUDIENCE);
  }
  const ::flatbuffers::String *lastModified() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LASTMODIFIED);
  }
  int32_t priority() const {
    return GetField<int32_t>(VT_PRIORITY, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AUDIENCE) &&
           verifier.VerifyVector(audience()) &&
           VerifyOffset(verifier, VT_LASTMODIFIED) &&
           verifier.VerifyString(lastModified()) &&
           VerifyField<int32_t>(verifier, VT_PRIORITY, 4) &&
           verifier.EndTable();
  }
};

struct AnnotationsBuilder {
  typedef Annotations Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_audience(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> audience) {
    fbb_.AddOffset(Annotations::VT_AUDIENCE, audience);
  }
  void add_lastModified(::flatbuffers::Offset<::flatbuffers::String> lastModified) {
    fbb_.AddOffset(Annotations::VT_LASTMODIFIED, lastModified);
  }
  void add_priority(int32_t priority) {
    fbb_.AddElement<int32_t>(Annotations::VT_PRIORITY, priority, 0);
  }
  explicit AnnotationsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Annotations> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Annotations>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Annotations> CreateAnnotations(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> audience = 0,
    ::flatbuffers::Offset<::flatbuffers::String> lastModified = 0,
    int32_t priority = 0) {
  AnnotationsBuilder builder_(_fbb);
  builder_.add_priority(priority);
  builder_.add_lastModified(lastModified);
  builder_.add_audience(audience);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Annotations> CreateAnnotationsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *audience = nullptr,
    const char *lastModified = nullptr,
    int32_t priority = 0) {
  auto audience__ = audience ? _fbb.CreateVector<int8_t>(*audience) : 0;
  auto lastModified__ = lastModified ? _fbb.CreateString(lastModified) : 0;
  return mcp::CreateAnnotations(
      _fbb,
      audience__,
      lastModified__,
      priority);
}

struct Error FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ErrorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_MESSAGE = 6,
    VT_DATA = 8
  };
  int32_t code() const {
    return GetField<int32_t>(VT_CODE, 0);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  const ::flatbuffers::String *data() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CODE, 4) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           verifier.EndTable();
  }
};

struct ErrorBuilder {
  typedef Error Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_code(int32_t code) {
    fbb_.AddElement<int32_t>(Error::VT_CODE, code, 0);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(Error::VT_MESSAGE, message);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::String> data) {
    fbb_.AddOffset(Error::VT_DATA, data);
  }
  explicit ErrorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Error> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Error>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Error> CreateError(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t code = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0,
    ::flatbuffers::Offset<::flatbuffers::String> data = 0) {
  ErrorBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_message(message);
  builder_.add_code(code);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Error> CreateErrorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t code = 0,
    const char *message = nullptr,
    const char *data = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  auto data__ = data ? _fbb.CreateString(data) : 0;
  return mcp::CreateError(
      _fbb,
      code,
      message__,
      data__);
}

struct Ping FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
};

struct PingBuilder {
  typedef Ping Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Ping::VT_ID, id);
  }
  explicit PingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Ping> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Ping>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Ping> CreatePing(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0) {
  PingBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Ping> CreatePingDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return mcp::CreatePing(
      _fbb,
      id__);
}

struct Pong FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PongBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
};

struct PongBuilder {
  typedef Pong Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Pong::VT_ID, id);
  }
  explicit PongBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Pong> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Pong>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Pong> CreatePong(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0) {
  PongBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Pong> CreatePongDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return mcp::CreatePong(
      _fbb,
      id__);
}

struct Request FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_JSONRPC = 4,
    VT_ID = 6,
    VT_METHOD = 8,
    VT_PARAMS = 10
  };
  const ::flatbuffers::String *jsonrpc() const {
    return GetPointer<const ::flatbuffers::String *>(VT_JSONRPC);
  }
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *method() const {
    return GetPointer<const ::flatbuffers::String *>(VT_METHOD);
  }
  const ::flatbuffers::String *params() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARAMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_JSONRPC) &&
           verifier.VerifyString(jsonrpc()) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.VerifyString(method()) &&
           VerifyOffset(verifier, VT_PARAMS) &&
           verifier.VerifyString(params()) &&
           verifier.EndTable();
  }
};

struct RequestBuilder {
  typedef Request Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_jsonrpc(::flatbuffers::Offset<::flatbuffers::String> jsonrpc) {
    fbb_.AddOffset(Request::VT_JSONRPC, jsonrpc);
  }
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Request::VT_ID, id);
  }
  void add_method(::flatbuffers::Offset<::flatbuffers::String> method) {
    fbb_.AddOffset(Request::VT_METHOD, method);
  }
  void add_params(::flatbuffers::Offset<::flatbuffers::String> params) {
    fbb_.AddOffset(Request::VT_PARAMS, params);
  }
  explicit RequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request> CreateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> jsonrpc = 0,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> method = 0,
    ::flatbuffers::Offset<::flatbuffers::String> params = 0) {
  RequestBuilder builder_(_fbb);
  builder_.add_params(params);
  builder_.add_method(method);
  builder_.add_id(id);
  builder_.add_jsonrpc(jsonrpc);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Request> CreateRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *jsonrpc = nullptr,
    const char *id = nullptr,
    const char *method = nullptr,
    const char *params = nullptr) {
  auto jsonrpc__ = jsonrpc ? _fbb.CreateString(jsonrpc) : 0;
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto method__ = method ? _fbb.CreateString(method) : 0;
  auto params__ = params ? _fbb.CreateString(params) : 0;
  return mcp::CreateRequest(
      _fbb,
      jsonrpc__,
      id__,
      method__,
      params__);
}

struct Response FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_JSONRPC = 4,
    VT_ID = 6,
    VT_RESULT = 8,
    VT_ERROR = 10
  };
  const ::flatbuffers::String *jsonrpc() const {
    return GetPointer<const ::flatbuffers::String *>(VT_JSONRPC);
  }
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  const mcp::Error *error() const {
    return GetPointer<const mcp::Error *>(VT_ERROR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_JSONRPC) &&
           verifier.VerifyString(jsonrpc()) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
};

struct ResponseBuilder {
  typedef Response Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_jsonrpc(::flatbuffers::Offset<::flatbuffers::String> jsonrpc) {
    fbb_.AddOffset(Response::VT_JSONRPC, jsonrpc);
  }
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Response::VT_ID, id);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(Response::VT_RESULT, result);
  }
  void add_error(::flatbuffers::Offset<mcp::Error> error) {
    fbb_.AddOffset(Response::VT_ERROR, error);
  }
  explicit ResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response> CreateResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> jsonrpc = 0,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    ::flatbuffers::Offset<mcp::Error> error = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_result(result);
  builder_.add_id(id);
  builder_.add_jsonrpc(jsonrpc);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Response> CreateResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *jsonrpc = nullptr,
    const char *id = nullptr,
    const char *result = nullptr,
    ::flatbuffers::Offset<mcp::Error> error = 0) {
  auto jsonrpc__ = jsonrpc ? _fbb.CreateString(jsonrpc) : 0;
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  return mcp::CreateResponse(
      _fbb,
      jsonrpc__,
      id__,
      result__,
      error);
}

struct Notification FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NotificationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_JSONRPC = 4,
    VT_METHOD = 6,
    VT_PARAMS = 8
  };
  const ::flatbuffers::String *jsonrpc() const {
    return GetPointer<const ::flatbuffers::String *>(VT_JSONRPC);
  }
  const ::flatbuffers::String *method() const {
    return GetPointer<const ::flatbuffers::String *>(VT_METHOD);
  }
  const ::flatbuffers::String *params() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARAMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_JSONRPC) &&
           verifier.VerifyString(jsonrpc()) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.VerifyString(method()) &&
           VerifyOffset(verifier, VT_PARAMS) &&
           verifier.VerifyString(params()) &&
           verifier.EndTable();
  }
};

struct NotificationBuilder {
  typedef Notification Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_jsonrpc(::flatbuffers::Offset<::flatbuffers::String> jsonrpc) {
    fbb_.AddOffset(Notification::VT_JSONRPC, jsonrpc);
  }
  void add_method(::flatbuffers::Offset<::flatbuffers::String> method) {
    fbb_.AddOffset(Notification::VT_METHOD, method);
  }
  void add_params(::flatbuffers::Offset<::flatbuffers::String> params) {
    fbb_.AddOffset(Notification::VT_PARAMS, params);
  }
  explicit NotificationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Notification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Notification>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Notification> CreateNotification(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> jsonrpc = 0,
    ::flatbuffers::Offset<::flatbuffers::String> method = 0,
    ::flatbuffers::Offset<::flatbuffers::String> params = 0) {
  NotificationBuilder builder_(_fbb);
  builder_.add_params(params);
  builder_.add_method(method);
  builder_.add_jsonrpc(jsonrpc);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Notification> CreateNotificationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *jsonrpc = nullptr,
    const char *method = nullptr,
    const char *params = nullptr) {
  auto jsonrpc__ = jsonrpc ? _fbb.CreateString(jsonrpc) : 0;
  auto method__ = method ? _fbb.CreateString(method) : 0;
  auto params__ = params ? _fbb.CreateString(params) : 0;
  return mcp::CreateNotification(
      _fbb,
      jsonrpc__,
      method__,
      params__);
}

struct Tool FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ToolBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DESCRIPTION = 6,
    VT_INPUTSCHEMA = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  const ::flatbuffers::String *inputSchema() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INPUTSCHEMA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_INPUTSCHEMA) &&
           verifier.VerifyString(inputSchema()) &&
           verifier.EndTable();
  }
};

struct ToolBuilder {
  typedef Tool Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Tool::VT_NAME, name);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(Tool::VT_DESCRIPTION, description);
  }
  void add_inputSchema(::flatbuffers::Offset<::flatbuffers::String> inputSchema) {
    fbb_.AddOffset(Tool::VT_INPUTSCHEMA, inputSchema);
  }
  explicit ToolBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Tool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Tool>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Tool> CreateTool(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    ::flatbuffers::Offset<::flatbuffers::String> inputSchema = 0) {
  ToolBuilder builder_(_fbb);
  builder_.add_inputSchema(inputSchema);
  builder_.add_description(description);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Tool> CreateToolDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *description = nullptr,
    const char *inputSchema = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto inputSchema__ = inputSchema ? _fbb.CreateString(inputSchema) : 0;
  return mcp::CreateTool(
      _fbb,
      name__,
      description__,
      inputSchema__);
}

struct ToolCall FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ToolCallBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ARGUMENTS = 6,
    VT_RESULT = 8,
    VT_ISERROR = 10,
    VT_ERROR = 12
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *arguments() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ARGUMENTS);
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  bool isError() const {
    return GetField<uint8_t>(VT_ISERROR, 0) != 0;
  }
  const mcp::Error *error() const {
    return GetPointer<const mcp::Error *>(VT_ERROR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_ARGUMENTS) &&
           verifier.VerifyString(arguments()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyField<uint8_t>(verifier, VT_ISERROR, 1) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
};

struct ToolCallBuilder {
  typedef ToolCall Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ToolCall::VT_NAME, name);
  }
  void add_arguments(::flatbuffers::Offset<::flatbuffers::String> arguments) {
    fbb_.AddOffset(ToolCall::VT_ARGUMENTS, arguments);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(ToolCall::VT_RESULT, result);
  }
  void add_isError(bool isError) {
    fbb_.AddElement<uint8_t>(ToolCall::VT_ISERROR, static_cast<uint8_t>(isError), 0);
  }
  void add_error(::flatbuffers::Offset<mcp::Error> error) {
    fbb_.AddOffset(ToolCall::VT_ERROR, error);
  }
  explicit ToolCallBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ToolCall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ToolCall>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ToolCall> CreateToolCall(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> arguments = 0,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    bool isError = false,
    ::flatbuffers::Offset<mcp::Error> error = 0) {
  ToolCallBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_result(result);
  builder_.add_arguments(arguments);
  builder_.add_name(name);
  builder_.add_isError(isError);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ToolCall> CreateToolCallDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *arguments = nullptr,
    const char *result = nullptr,
    bool isError = false,
    ::flatbuffers::Offset<mcp::Error> error = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto arguments__ = arguments ? _fbb.CreateString(arguments) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  return mcp::CreateToolCall(
      _fbb,
      name__,
      arguments__,
      result__,
      isError,
      error);
}

struct TextContent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TextContentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_TEXT = 6
  };
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
};

struct TextContentBuilder {
  typedef TextContent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(TextContent::VT_TYPE, type);
  }
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(TextContent::VT_TEXT, text);
  }
  explicit TextContentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TextContent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TextContent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TextContent> CreateTextContent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0) {
  TextContentBuilder builder_(_fbb);
  builder_.add_text(text);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TextContent> CreateTextContentDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *text = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return mcp::CreateTextContent(
      _fbb,
      type__,
      text__);
}

struct ImageContent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ImageContentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DATA = 6,
    VT_MIMETYPE = 8
  };
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  const ::flatbuffers::String *data() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATA);
  }
  const ::flatbuffers::String *mimeType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MIMETYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           VerifyOffset(verifier, VT_MIMETYPE) &&
           verifier.VerifyString(mimeType()) &&
           verifier.EndTable();
  }
};

struct ImageContentBuilder {
  typedef ImageContent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(ImageContent::VT_TYPE, type);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::String> data) {
    fbb_.AddOffset(ImageContent::VT_DATA, data);
  }
  void add_mimeType(::flatbuffers::Offset<::flatbuffers::String> mimeType) {
    fbb_.AddOffset(ImageContent::VT_MIMETYPE, mimeType);
  }
  explicit ImageContentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ImageContent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ImageContent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ImageContent> CreateImageContent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> data = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mimeType = 0) {
  ImageContentBuilder builder_(_fbb);
  builder_.add_mimeType(mimeType);
  builder_.add_data(data);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ImageContent> CreateImageContentDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *data = nullptr,
    const char *mimeType = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto data__ = data ? _fbb.CreateString(data) : 0;
  auto mimeType__ = mimeType ? _fbb.CreateString(mimeType) : 0;
  return mcp::CreateImageContent(
      _fbb,
      type__,
      data__,
      mimeType__);
}

struct AudioContent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AudioContentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DATA = 6,
    VT_MIMETYPE = 8
  };
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  const ::flatbuffers::String *data() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATA);
  }
  const ::flatbuffers::String *mimeType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MIMETYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           VerifyOffset(verifier, VT_MIMETYPE) &&
           verifier.VerifyString(mimeType()) &&
           verifier.EndTable();
  }
};

struct AudioContentBuilder {
  typedef AudioContent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(AudioContent::VT_TYPE, type);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::String> data) {
    fbb_.AddOffset(AudioContent::VT_DATA, data);
  }
  void add_mimeType(::flatbuffers::Offset<::flatbuffers::String> mimeType) {
    fbb_.AddOffset(AudioContent::VT_MIMETYPE, mimeType);
  }
  explicit AudioContentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AudioContent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AudioContent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AudioContent> CreateAudioContent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> data = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mimeType = 0) {
  AudioContentBuilder builder_(_fbb);
  builder_.add_mimeType(mimeType);
  builder_.add_data(data);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AudioContent> CreateAudioContentDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *data = nullptr,
    const char *mimeType = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto data__ = data ? _fbb.CreateString(data) : 0;
  auto mimeType__ = mimeType ? _fbb.CreateString(mimeType) : 0;
  return mcp::CreateAudioContent(
      _fbb,
      type__,
      data__,
      mimeType__);
}

struct VideoContent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VideoContentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DATA = 6,
    VT_MIMETYPE = 8
  };
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  const ::flatbuffers::String *data() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATA);
  }
  const ::flatbuffers::String *mimeType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MIMETYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           VerifyOffset(verifier, VT_MIMETYPE) &&
           verifier.VerifyString(mimeType()) &&
           verifier.EndTable();
  }
};

struct VideoContentBuilder {
  typedef VideoContent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(VideoContent::VT_TYPE, type);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::String> data) {
    fbb_.AddOffset(VideoContent::VT_DATA, data);
  }
  void add_mimeType(::flatbuffers::Offset<::flatbuffers::String> mimeType) {
    fbb_.AddOffset(VideoContent::VT_MIMETYPE, mimeType);
  }
  explicit VideoContentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VideoContent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VideoContent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VideoContent> CreateVideoContent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> data = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mimeType = 0) {
  VideoContentBuilder builder_(_fbb);
  builder_.add_mimeType(mimeType);
  builder_.add_data(data);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VideoContent> CreateVideoContentDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *data = nullptr,
    const char *mimeType = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto data__ = data ? _fbb.CreateString(data) : 0;
  auto mimeType__ = mimeType ? _fbb.CreateString(mimeType) : 0;
  return mcp::CreateVideoContent(
      _fbb,
      type__,
      data__,
      mimeType__);
}

struct BlobContent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BlobContentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DATA = 6,
    VT_MIMETYPE = 8,
    VT_BLOBID = 10
  };
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  const ::flatbuffers::String *data() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATA);
  }
  const ::flatbuffers::String *mimeType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MIMETYPE);
  }
  const ::flatbuffers::String *blobId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BLOBID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           VerifyOffset(verifier, VT_MIMETYPE) &&
           verifier.VerifyString(mimeType()) &&
           VerifyOffset(verifier, VT_BLOBID) &&
           verifier.VerifyString(blobId()) &&
           verifier.EndTable();
  }
};

struct BlobContentBuilder {
  typedef BlobContent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(BlobContent::VT_TYPE, type);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::String> data) {
    fbb_.AddOffset(BlobContent::VT_DATA, data);
  }
  void add_mimeType(::flatbuffers::Offset<::flatbuffers::String> mimeType) {
    fbb_.AddOffset(BlobContent::VT_MIMETYPE, mimeType);
  }
  void add_blobId(::flatbuffers::Offset<::flatbuffers::String> blobId) {
    fbb_.AddOffset(BlobContent::VT_BLOBID, blobId);
  }
  explicit BlobContentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BlobContent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BlobContent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BlobContent> CreateBlobContent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> data = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mimeType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> blobId = 0) {
  BlobContentBuilder builder_(_fbb);
  builder_.add_blobId(blobId);
  builder_.add_mimeType(mimeType);
  builder_.add_data(data);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BlobContent> CreateBlobContentDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *data = nullptr,
    const char *mimeType = nullptr,
    const char *blobId = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto data__ = data ? _fbb.CreateString(data) : 0;
  auto mimeType__ = mimeType ? _fbb.CreateString(mimeType) : 0;
  auto blobId__ = blobId ? _fbb.CreateString(blobId) : 0;
  return mcp::CreateBlobContent(
      _fbb,
      type__,
      data__,
      mimeType__,
      blobId__);
}

struct ToolResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ToolResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENT_TYPE = 4,
    VT_CONTENT = 6,
    VT_ISERROR = 8,
    VT_ERROR = 10
  };
  const ::flatbuffers::Vector<uint8_t> *content_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CONTENT_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *content() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_CONTENT);
  }
  bool isError() const {
    return GetField<uint8_t>(VT_ISERROR, 0) != 0;
  }
  const mcp::Error *error() const {
    return GetPointer<const mcp::Error *>(VT_ERROR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTENT_TYPE) &&
           verifier.VerifyVector(content_type()) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyVector(content()) &&
           VerifyContentVector(verifier, content(), content_type()) &&
           VerifyField<uint8_t>(verifier, VT_ISERROR, 1) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
};

struct ToolResultBuilder {
  typedef ToolResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_content_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> content_type) {
    fbb_.AddOffset(ToolResult::VT_CONTENT_TYPE, content_type);
  }
  void add_content(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> content) {
    fbb_.AddOffset(ToolResult::VT_CONTENT, content);
  }
  void add_isError(bool isError) {
    fbb_.AddElement<uint8_t>(ToolResult::VT_ISERROR, static_cast<uint8_t>(isError), 0);
  }
  void add_error(::flatbuffers::Offset<mcp::Error> error) {
    fbb_.AddOffset(ToolResult::VT_ERROR, error);
  }
  explicit ToolResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ToolResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ToolResult>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ToolResult> CreateToolResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> content_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> content = 0,
    bool isError = false,
    ::flatbuffers::Offset<mcp::Error> error = 0) {
  ToolResultBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_content(content);
  builder_.add_content_type(content_type);
  builder_.add_isError(isError);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ToolResult> CreateToolResultDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *content_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *content = nullptr,
    bool isError = false,
    ::flatbuffers::Offset<mcp::Error> error = 0) {
  auto content_type__ = content_type ? _fbb.CreateVector<uint8_t>(*content_type) : 0;
  auto content__ = content ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*content) : 0;
  return mcp::CreateToolResult(
      _fbb,
      content_type__,
      content__,
      isError,
      error);
}

struct Resource FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResourceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_URI = 4,
    VT_NAME = 6,
    VT_DESCRIPTION = 8,
    VT_MIMETYPE = 10
  };
  const ::flatbuffers::String *uri() const {
    return GetPointer<const ::flatbuffers::String *>(VT_URI);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  const ::flatbuffers::String *mimeType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MIMETYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_URI) &&
           verifier.VerifyString(uri()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_MIMETYPE) &&
           verifier.VerifyString(mimeType()) &&
           verifier.EndTable();
  }
};

struct ResourceBuilder {
  typedef Resource Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uri(::flatbuffers::Offset<::flatbuffers::String> uri) {
    fbb_.AddOffset(Resource::VT_URI, uri);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Resource::VT_NAME, name);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(Resource::VT_DESCRIPTION, description);
  }
  void add_mimeType(::flatbuffers::Offset<::flatbuffers::String> mimeType) {
    fbb_.AddOffset(Resource::VT_MIMETYPE, mimeType);
  }
  explicit ResourceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Resource> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Resource>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Resource> CreateResource(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> uri = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mimeType = 0) {
  ResourceBuilder builder_(_fbb);
  builder_.add_mimeType(mimeType);
  builder_.add_description(description);
  builder_.add_name(name);
  builder_.add_uri(uri);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Resource> CreateResourceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *uri = nullptr,
    const char *name = nullptr,
    const char *description = nullptr,
    const char *mimeType = nullptr) {
  auto uri__ = uri ? _fbb.CreateString(uri) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto mimeType__ = mimeType ? _fbb.CreateString(mimeType) : 0;
  return mcp::CreateResource(
      _fbb,
      uri__,
      name__,
      description__,
      mimeType__);
}

struct ResourceContents FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResourceContentsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_URI = 4,
    VT_MIMETYPE = 6,
    VT_TEXT = 8,
    VT_BLOB = 10
  };
  const ::flatbuffers::String *uri() const {
    return GetPointer<const ::flatbuffers::String *>(VT_URI);
  }
  const ::flatbuffers::String *mimeType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MIMETYPE);
  }
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  const ::flatbuffers::String *blob() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BLOB);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_URI) &&
           verifier.VerifyString(uri()) &&
           VerifyOffset(verifier, VT_MIMETYPE) &&
           verifier.VerifyString(mimeType()) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyOffset(verifier, VT_BLOB) &&
           verifier.VerifyString(blob()) &&
           verifier.EndTable();
  }
};

struct ResourceContentsBuilder {
  typedef ResourceContents Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uri(::flatbuffers::Offset<::flatbuffers::String> uri) {
    fbb_.AddOffset(ResourceContents::VT_URI, uri);
  }
  void add_mimeType(::flatbuffers::Offset<::flatbuffers::String> mimeType) {
    fbb_.AddOffset(ResourceContents::VT_MIMETYPE, mimeType);
  }
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(ResourceContents::VT_TEXT, text);
  }
  void add_blob(::flatbuffers::Offset<::flatbuffers::String> blob) {
    fbb_.AddOffset(ResourceContents::VT_BLOB, blob);
  }
  explicit ResourceContentsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResourceContents> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResourceContents>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResourceContents> CreateResourceContents(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> uri = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mimeType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0,
    ::flatbuffers::Offset<::flatbuffers::String> blob = 0) {
  ResourceContentsBuilder builder_(_fbb);
  builder_.add_blob(blob);
  builder_.add_text(text);
  builder_.add_mimeType(mimeType);
  builder_.add_uri(uri);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResourceContents> CreateResourceContentsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *uri = nullptr,
    const char *mimeType = nullptr,
    const char *text = nullptr,
    const char *blob = nullptr) {
  auto uri__ = uri ? _fbb.CreateString(uri) : 0;
  auto mimeType__ = mimeType ? _fbb.CreateString(mimeType) : 0;
  auto text__ = text ? _fbb.CreateString(text) : 0;
  auto blob__ = blob ? _fbb.CreateString(blob) : 0;
  return mcp::CreateResourceContents(
      _fbb,
      uri__,
      mimeType__,
      text__,
      blob__);
}

struct BlobResourceContents FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BlobResourceContentsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOBID = 4,
    VT_MIMETYPE = 6,
    VT_DATA = 8
  };
  const ::flatbuffers::String *blobId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BLOBID);
  }
  const ::flatbuffers::String *mimeType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MIMETYPE);
  }
  const ::flatbuffers::String *data() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOBID) &&
           verifier.VerifyString(blobId()) &&
           VerifyOffset(verifier, VT_MIMETYPE) &&
           verifier.VerifyString(mimeType()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           verifier.EndTable();
  }
};

struct BlobResourceContentsBuilder {
  typedef BlobResourceContents Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_blobId(::flatbuffers::Offset<::flatbuffers::String> blobId) {
    fbb_.AddOffset(BlobResourceContents::VT_BLOBID, blobId);
  }
  void add_mimeType(::flatbuffers::Offset<::flatbuffers::String> mimeType) {
    fbb_.AddOffset(BlobResourceContents::VT_MIMETYPE, mimeType);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::String> data) {
    fbb_.AddOffset(BlobResourceContents::VT_DATA, data);
  }
  explicit BlobResourceContentsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BlobResourceContents> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BlobResourceContents>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BlobResourceContents> CreateBlobResourceContents(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> blobId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mimeType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> data = 0) {
  BlobResourceContentsBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_mimeType(mimeType);
  builder_.add_blobId(blobId);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BlobResourceContents> CreateBlobResourceContentsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *blobId = nullptr,
    const char *mimeType = nullptr,
    const char *data = nullptr) {
  auto blobId__ = blobId ? _fbb.CreateString(blobId) : 0;
  auto mimeType__ = mimeType ? _fbb.CreateString(mimeType) : 0;
  auto data__ = data ? _fbb.CreateString(data) : 0;
  return mcp::CreateBlobResourceContents(
      _fbb,
      blobId__,
      mimeType__,
      data__);
}

struct PromptArgument FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PromptArgumentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DESCRIPTION = 6,
    VT_REQUIRED = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  bool required() const {
    return GetField<uint8_t>(VT_REQUIRED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyField<uint8_t>(verifier, VT_REQUIRED, 1) &&
           verifier.EndTable();
  }
};

struct PromptArgumentBuilder {
  typedef PromptArgument Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(PromptArgument::VT_NAME, name);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(PromptArgument::VT_DESCRIPTION, description);
  }
  void add_required(bool required) {
    fbb_.AddElement<uint8_t>(PromptArgument::VT_REQUIRED, static_cast<uint8_t>(required), 0);
  }
  explicit PromptArgumentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PromptArgument> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PromptArgument>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PromptArgument> CreatePromptArgument(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    bool required = false) {
  PromptArgumentBuilder builder_(_fbb);
  builder_.add_description(description);
  builder_.add_name(name);
  builder_.add_required(required);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PromptArgument> CreatePromptArgumentDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *description = nullptr,
    bool required = false) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  return mcp::CreatePromptArgument(
      _fbb,
      name__,
      description__,
      required);
}

struct Prompt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PromptBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DESCRIPTION = 6,
    VT_ARGUMENTS = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::PromptArgument>> *arguments() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::PromptArgument>> *>(VT_ARGUMENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           verifier.VerifyVectorOfTables(arguments()) &&
           verifier.EndTable();
  }
};

struct PromptBuilder {
  typedef Prompt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Prompt::VT_NAME, name);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(Prompt::VT_DESCRIPTION, description);
  }
  void add_arguments(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::PromptArgument>>> arguments) {
    fbb_.AddOffset(Prompt::VT_ARGUMENTS, arguments);
  }
  explicit PromptBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Prompt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Prompt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Prompt> CreatePrompt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::PromptArgument>>> arguments = 0) {
  PromptBuilder builder_(_fbb);
  builder_.add_arguments(arguments);
  builder_.add_description(description);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Prompt> CreatePromptDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *description = nullptr,
    const std::vector<::flatbuffers::Offset<mcp::PromptArgument>> *arguments = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto arguments__ = arguments ? _fbb.CreateVector<::flatbuffers::Offset<mcp::PromptArgument>>(*arguments) : 0;
  return mcp::CreatePrompt(
      _fbb,
      name__,
      description__,
      arguments__);
}

struct Session FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SessionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSIONID = 4,
    VT_CLIENTID = 6,
    VT_CAPABILITIES = 8,
    VT_METADATA = 10
  };
  const ::flatbuffers::String *sessionId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SESSIONID);
  }
  const ::flatbuffers::String *clientId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLIENTID);
  }
  const ::flatbuffers::String *capabilities() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CAPABILITIES);
  }
  const ::flatbuffers::String *metadata() const {
    return GetPointer<const ::flatbuffers::String *>(VT_METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SESSIONID) &&
           verifier.VerifyString(sessionId()) &&
           VerifyOffset(verifier, VT_CLIENTID) &&
           verifier.VerifyString(clientId()) &&
           VerifyOffset(verifier, VT_CAPABILITIES) &&
           verifier.VerifyString(capabilities()) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyString(metadata()) &&
           verifier.EndTable();
  }
};

struct SessionBuilder {
  typedef Session Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sessionId(::flatbuffers::Offset<::flatbuffers::String> sessionId) {
    fbb_.AddOffset(Session::VT_SESSIONID, sessionId);
  }
  void add_clientId(::flatbuffers::Offset<::flatbuffers::String> clientId) {
    fbb_.AddOffset(Session::VT_CLIENTID, clientId);
  }
  void add_capabilities(::flatbuffers::Offset<::flatbuffers::String> capabilities) {
    fbb_.AddOffset(Session::VT_CAPABILITIES, capabilities);
  }
  void add_metadata(::flatbuffers::Offset<::flatbuffers::String> metadata) {
    fbb_.AddOffset(Session::VT_METADATA, metadata);
  }
  explicit SessionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Session> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Session>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Session> CreateSession(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> sessionId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> clientId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> capabilities = 0,
    ::flatbuffers::Offset<::flatbuffers::String> metadata = 0) {
  SessionBuilder builder_(_fbb);
  builder_.add_metadata(metadata);
  builder_.add_capabilities(capabilities);
  builder_.add_clientId(clientId);
  builder_.add_sessionId(sessionId);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Session> CreateSessionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *sessionId = nullptr,
    const char *clientId = nullptr,
    const char *capabilities = nullptr,
    const char *metadata = nullptr) {
  auto sessionId__ = sessionId ? _fbb.CreateString(sessionId) : 0;
  auto clientId__ = clientId ? _fbb.CreateString(clientId) : 0;
  auto capabilities__ = capabilities ? _fbb.CreateString(capabilities) : 0;
  auto metadata__ = metadata ? _fbb.CreateString(metadata) : 0;
  return mcp::CreateSession(
      _fbb,
      sessionId__,
      clientId__,
      capabilities__,
      metadata__);
}

struct TransportConfig FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TransportConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_CONFIG = 6
  };
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  const ::flatbuffers::String *config() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONFIG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_CONFIG) &&
           verifier.VerifyString(config()) &&
           verifier.EndTable();
  }
};

struct TransportConfigBuilder {
  typedef TransportConfig Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(TransportConfig::VT_TYPE, type);
  }
  void add_config(::flatbuffers::Offset<::flatbuffers::String> config) {
    fbb_.AddOffset(TransportConfig::VT_CONFIG, config);
  }
  explicit TransportConfigBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TransportConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TransportConfig>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TransportConfig> CreateTransportConfig(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> config = 0) {
  TransportConfigBuilder builder_(_fbb);
  builder_.add_config(config);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TransportConfig> CreateTransportConfigDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *config = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto config__ = config ? _fbb.CreateString(config) : 0;
  return mcp::CreateTransportConfig(
      _fbb,
      type__,
      config__);
}

struct ServerCapabilities FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ServerCapabilitiesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOOLS = 4,
    VT_RESOURCES = 6,
    VT_PROMPTS = 8,
    VT_LOGGING = 10
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::Tool>> *tools() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::Tool>> *>(VT_TOOLS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::Resource>> *resources() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::Resource>> *>(VT_RESOURCES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::Prompt>> *prompts() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::Prompt>> *>(VT_PROMPTS);
  }
  bool logging() const {
    return GetField<uint8_t>(VT_LOGGING, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOOLS) &&
           verifier.VerifyVector(tools()) &&
           verifier.VerifyVectorOfTables(tools()) &&
           VerifyOffset(verifier, VT_RESOURCES) &&
           verifier.VerifyVector(resources()) &&
           verifier.VerifyVectorOfTables(resources()) &&
           VerifyOffset(verifier, VT_PROMPTS) &&
           verifier.VerifyVector(prompts()) &&
           verifier.VerifyVectorOfTables(prompts()) &&
           VerifyField<uint8_t>(verifier, VT_LOGGING, 1) &&
           verifier.EndTable();
  }
};

struct ServerCapabilitiesBuilder {
  typedef ServerCapabilities Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tools(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::Tool>>> tools) {
    fbb_.AddOffset(ServerCapabilities::VT_TOOLS, tools);
  }
  void add_resources(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::Resource>>> resources) {
    fbb_.AddOffset(ServerCapabilities::VT_RESOURCES, resources);
  }
  void add_prompts(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::Prompt>>> prompts) {
    fbb_.AddOffset(ServerCapabilities::VT_PROMPTS, prompts);
  }
  void add_logging(bool logging) {
    fbb_.AddElement<uint8_t>(ServerCapabilities::VT_LOGGING, static_cast<uint8_t>(logging), 0);
  }
  explicit ServerCapabilitiesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ServerCapabilities> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ServerCapabilities>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ServerCapabilities> CreateServerCapabilities(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::Tool>>> tools = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::Resource>>> resources = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::Prompt>>> prompts = 0,
    bool logging = false) {
  ServerCapabilitiesBuilder builder_(_fbb);
  builder_.add_prompts(prompts);
  builder_.add_resources(resources);
  builder_.add_tools(tools);
  builder_.add_logging(logging);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ServerCapabilities> CreateServerCapabilitiesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<mcp::Tool>> *tools = nullptr,
    const std::vector<::flatbuffers::Offset<mcp::Resource>> *resources = nullptr,
    const std::vector<::flatbuffers::Offset<mcp::Prompt>> *prompts = nullptr,
    bool logging = false) {
  auto tools__ = tools ? _fbb.CreateVector<::flatbuffers::Offset<mcp::Tool>>(*tools) : 0;
  auto resources__ = resources ? _fbb.CreateVector<::flatbuffers::Offset<mcp::Resource>>(*resources) : 0;
  auto prompts__ = prompts ? _fbb.CreateVector<::flatbuffers::Offset<mcp::Prompt>>(*prompts) : 0;
  return mcp::CreateServerCapabilities(
      _fbb,
      tools__,
      resources__,
      prompts__,
      logging);
}

struct ClientCapabilities FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClientCapabilitiesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXPERIMENTAL = 4,
    VT_SAMPLING = 6
  };
  const ::flatbuffers::String *experimental() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXPERIMENTAL);
  }
  const ::flatbuffers::String *sampling() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SAMPLING);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EXPERIMENTAL) &&
           verifier.VerifyString(experimental()) &&
           VerifyOffset(verifier, VT_SAMPLING) &&
           verifier.VerifyString(sampling()) &&
           verifier.EndTable();
  }
};

struct ClientCapabilitiesBuilder {
  typedef ClientCapabilities Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_experimental(::flatbuffers::Offset<::flatbuffers::String> experimental) {
    fbb_.AddOffset(ClientCapabilities::VT_EXPERIMENTAL, experimental);
  }
  void add_sampling(::flatbuffers::Offset<::flatbuffers::String> sampling) {
    fbb_.AddOffset(ClientCapabilities::VT_SAMPLING, sampling);
  }
  explicit ClientCapabilitiesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ClientCapabilities> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ClientCapabilities>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ClientCapabilities> CreateClientCapabilities(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> experimental = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sampling = 0) {
  ClientCapabilitiesBuilder builder_(_fbb);
  builder_.add_sampling(sampling);
  builder_.add_experimental(experimental);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ClientCapabilities> CreateClientCapabilitiesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *experimental = nullptr,
    const char *sampling = nullptr) {
  auto experimental__ = experimental ? _fbb.CreateString(experimental) : 0;
  auto sampling__ = sampling ? _fbb.CreateString(sampling) : 0;
  return mcp::CreateClientCapabilities(
      _fbb,
      experimental__,
      sampling__);
}

struct InitializeRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InitializeRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROTOCOLVERSION = 4,
    VT_CAPABILITIES = 6,
    VT_CLIENTINFO = 8
  };
  const ::flatbuffers::String *protocolVersion() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROTOCOLVERSION);
  }
  const mcp::ClientCapabilities *capabilities() const {
    return GetPointer<const mcp::ClientCapabilities *>(VT_CAPABILITIES);
  }
  const ::flatbuffers::String *clientInfo() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLIENTINFO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROTOCOLVERSION) &&
           verifier.VerifyString(protocolVersion()) &&
           VerifyOffset(verifier, VT_CAPABILITIES) &&
           verifier.VerifyTable(capabilities()) &&
           VerifyOffset(verifier, VT_CLIENTINFO) &&
           verifier.VerifyString(clientInfo()) &&
           verifier.EndTable();
  }
};

struct InitializeRequestBuilder {
  typedef InitializeRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_protocolVersion(::flatbuffers::Offset<::flatbuffers::String> protocolVersion) {
    fbb_.AddOffset(InitializeRequest::VT_PROTOCOLVERSION, protocolVersion);
  }
  void add_capabilities(::flatbuffers::Offset<mcp::ClientCapabilities> capabilities) {
    fbb_.AddOffset(InitializeRequest::VT_CAPABILITIES, capabilities);
  }
  void add_clientInfo(::flatbuffers::Offset<::flatbuffers::String> clientInfo) {
    fbb_.AddOffset(InitializeRequest::VT_CLIENTINFO, clientInfo);
  }
  explicit InitializeRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InitializeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InitializeRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InitializeRequest> CreateInitializeRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> protocolVersion = 0,
    ::flatbuffers::Offset<mcp::ClientCapabilities> capabilities = 0,
    ::flatbuffers::Offset<::flatbuffers::String> clientInfo = 0) {
  InitializeRequestBuilder builder_(_fbb);
  builder_.add_clientInfo(clientInfo);
  builder_.add_capabilities(capabilities);
  builder_.add_protocolVersion(protocolVersion);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<InitializeRequest> CreateInitializeRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *protocolVersion = nullptr,
    ::flatbuffers::Offset<mcp::ClientCapabilities> capabilities = 0,
    const char *clientInfo = nullptr) {
  auto protocolVersion__ = protocolVersion ? _fbb.CreateString(protocolVersion) : 0;
  auto clientInfo__ = clientInfo ? _fbb.CreateString(clientInfo) : 0;
  return mcp::CreateInitializeRequest(
      _fbb,
      protocolVersion__,
      capabilities,
      clientInfo__);
}

struct InitializeResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InitializeResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROTOCOLVERSION = 4,
    VT_CAPABILITIES = 6,
    VT_SERVERINFO = 8
  };
  const ::flatbuffers::String *protocolVersion() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROTOCOLVERSION);
  }
  const mcp::ServerCapabilities *capabilities() const {
    return GetPointer<const mcp::ServerCapabilities *>(VT_CAPABILITIES);
  }
  const ::flatbuffers::String *serverInfo() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SERVERINFO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROTOCOLVERSION) &&
           verifier.VerifyString(protocolVersion()) &&
           VerifyOffset(verifier, VT_CAPABILITIES) &&
           verifier.VerifyTable(capabilities()) &&
           VerifyOffset(verifier, VT_SERVERINFO) &&
           verifier.VerifyString(serverInfo()) &&
           verifier.EndTable();
  }
};

struct InitializeResponseBuilder {
  typedef InitializeResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_protocolVersion(::flatbuffers::Offset<::flatbuffers::String> protocolVersion) {
    fbb_.AddOffset(InitializeResponse::VT_PROTOCOLVERSION, protocolVersion);
  }
  void add_capabilities(::flatbuffers::Offset<mcp::ServerCapabilities> capabilities) {
    fbb_.AddOffset(InitializeResponse::VT_CAPABILITIES, capabilities);
  }
  void add_serverInfo(::flatbuffers::Offset<::flatbuffers::String> serverInfo) {
    fbb_.AddOffset(InitializeResponse::VT_SERVERINFO, serverInfo);
  }
  explicit InitializeResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InitializeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InitializeResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InitializeResponse> CreateInitializeResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> protocolVersion = 0,
    ::flatbuffers::Offset<mcp::ServerCapabilities> capabilities = 0,
    ::flatbuffers::Offset<::flatbuffers::String> serverInfo = 0) {
  InitializeResponseBuilder builder_(_fbb);
  builder_.add_serverInfo(serverInfo);
  builder_.add_capabilities(capabilities);
  builder_.add_protocolVersion(protocolVersion);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<InitializeResponse> CreateInitializeResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *protocolVersion = nullptr,
    ::flatbuffers::Offset<mcp::ServerCapabilities> capabilities = 0,
    const char *serverInfo = nullptr) {
  auto protocolVersion__ = protocolVersion ? _fbb.CreateString(protocolVersion) : 0;
  auto serverInfo__ = serverInfo ? _fbb.CreateString(serverInfo) : 0;
  return mcp::CreateInitializeResponse(
      _fbb,
      protocolVersion__,
      capabilities,
      serverInfo__);
}

struct PrimitiveSchemaDefinition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PrimitiveSchemaDefinitionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TITLE = 4,
    VT_DESCRIPTION = 6
  };
  const ::flatbuffers::String *title() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TITLE);
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TITLE) &&
           verifier.VerifyString(title()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           verifier.EndTable();
  }
};

struct PrimitiveSchemaDefinitionBuilder {
  typedef PrimitiveSchemaDefinition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_title(::flatbuffers::Offset<::flatbuffers::String> title) {
    fbb_.AddOffset(PrimitiveSchemaDefinition::VT_TITLE, title);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(PrimitiveSchemaDefinition::VT_DESCRIPTION, description);
  }
  explicit PrimitiveSchemaDefinitionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PrimitiveSchemaDefinition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PrimitiveSchemaDefinition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PrimitiveSchemaDefinition> CreatePrimitiveSchemaDefinition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> title = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0) {
  PrimitiveSchemaDefinitionBuilder builder_(_fbb);
  builder_.add_description(description);
  builder_.add_title(title);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PrimitiveSchemaDefinition> CreatePrimitiveSchemaDefinitionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *title = nullptr,
    const char *description = nullptr) {
  auto title__ = title ? _fbb.CreateString(title) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  return mcp::CreatePrimitiveSchemaDefinition(
      _fbb,
      title__,
      description__);
}

struct BooleanSchema FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BooleanSchemaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEF = 4,
    VT_DEFAULT_ = 6
  };
  const mcp::PrimitiveSchemaDefinition *def() const {
    return GetPointer<const mcp::PrimitiveSchemaDefinition *>(VT_DEF);
  }
  bool default_() const {
    return GetField<uint8_t>(VT_DEFAULT_, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEF) &&
           verifier.VerifyTable(def()) &&
           VerifyField<uint8_t>(verifier, VT_DEFAULT_, 1) &&
           verifier.EndTable();
  }
};

struct BooleanSchemaBuilder {
  typedef BooleanSchema Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_def(::flatbuffers::Offset<mcp::PrimitiveSchemaDefinition> def) {
    fbb_.AddOffset(BooleanSchema::VT_DEF, def);
  }
  void add_default_(bool default_) {
    fbb_.AddElement<uint8_t>(BooleanSchema::VT_DEFAULT_, static_cast<uint8_t>(default_), 0);
  }
  explicit BooleanSchemaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BooleanSchema> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BooleanSchema>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BooleanSchema> CreateBooleanSchema(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<mcp::PrimitiveSchemaDefinition> def = 0,
    bool default_ = false) {
  BooleanSchemaBuilder builder_(_fbb);
  builder_.add_def(def);
  builder_.add_default_(default_);
  return builder_.Finish();
}

struct NumberSchema FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NumberSchemaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEF = 4,
    VT_DEFAULT_ = 6,
    VT_MINIMUM = 8,
    VT_MAXIMUM = 10
  };
  const mcp::PrimitiveSchemaDefinition *def() const {
    return GetPointer<const mcp::PrimitiveSchemaDefinition *>(VT_DEF);
  }
  double default_() const {
    return GetField<double>(VT_DEFAULT_, 0.0);
  }
  double minimum() const {
    return GetField<double>(VT_MINIMUM, 0.0);
  }
  double maximum() const {
    return GetField<double>(VT_MAXIMUM, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEF) &&
           verifier.VerifyTable(def()) &&
           VerifyField<double>(verifier, VT_DEFAULT_, 8) &&
           VerifyField<double>(verifier, VT_MINIMUM, 8) &&
           VerifyField<double>(verifier, VT_MAXIMUM, 8) &&
           verifier.EndTable();
  }
};

struct NumberSchemaBuilder {
  typedef NumberSchema Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_def(::flatbuffers::Offset<mcp::PrimitiveSchemaDefinition> def) {
    fbb_.AddOffset(NumberSchema::VT_DEF, def);
  }
  void add_default_(double default_) {
    fbb_.AddElement<double>(NumberSchema::VT_DEFAULT_, default_, 0.0);
  }
  void add_minimum(double minimum) {
    fbb_.AddElement<double>(NumberSchema::VT_MINIMUM, minimum, 0.0);
  }
  void add_maximum(double maximum) {
    fbb_.AddElement<double>(NumberSchema::VT_MAXIMUM, maximum, 0.0);
  }
  explicit NumberSchemaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NumberSchema> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NumberSchema>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NumberSchema> CreateNumberSchema(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<mcp::PrimitiveSchemaDefinition> def = 0,
    double default_ = 0.0,
    double minimum = 0.0,
    double maximum = 0.0) {
  NumberSchemaBuilder builder_(_fbb);
  builder_.add_maximum(maximum);
  builder_.add_minimum(minimum);
  builder_.add_default_(default_);
  builder_.add_def(def);
  return builder_.Finish();
}

struct StringSchema FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringSchemaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEF = 4,
    VT_DEFAULT_ = 6,
    VT_ENUMVALUES = 8
  };
  const mcp::PrimitiveSchemaDefinition *def() const {
    return GetPointer<const mcp::PrimitiveSchemaDefinition *>(VT_DEF);
  }
  const ::flatbuffers::String *default_() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEFAULT_);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *enumValues() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ENUMVALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEF) &&
           verifier.VerifyTable(def()) &&
           VerifyOffset(verifier, VT_DEFAULT_) &&
           verifier.VerifyString(default_()) &&
           VerifyOffset(verifier, VT_ENUMVALUES) &&
           verifier.VerifyVector(enumValues()) &&
           verifier.VerifyVectorOfStrings(enumValues()) &&
           verifier.EndTable();
  }
};

struct StringSchemaBuilder {
  typedef StringSchema Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_def(::flatbuffers::Offset<mcp::PrimitiveSchemaDefinition> def) {
    fbb_.AddOffset(StringSchema::VT_DEF, def);
  }
  void add_default_(::flatbuffers::Offset<::flatbuffers::String> default_) {
    fbb_.AddOffset(StringSchema::VT_DEFAULT_, default_);
  }
  void add_enumValues(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> enumValues) {
    fbb_.AddOffset(StringSchema::VT_ENUMVALUES, enumValues);
  }
  explicit StringSchemaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StringSchema> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StringSchema>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StringSchema> CreateStringSchema(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<mcp::PrimitiveSchemaDefinition> def = 0,
    ::flatbuffers::Offset<::flatbuffers::String> default_ = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> enumValues = 0) {
  StringSchemaBuilder builder_(_fbb);
  builder_.add_enumValues(enumValues);
  builder_.add_default_(default_);
  builder_.add_def(def);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StringSchema> CreateStringSchemaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<mcp::PrimitiveSchemaDefinition> def = 0,
    const char *default_ = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *enumValues = nullptr) {
  auto default___ = default_ ? _fbb.CreateString(default_) : 0;
  auto enumValues__ = enumValues ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*enumValues) : 0;
  return mcp::CreateStringSchema(
      _fbb,
      def,
      default___,
      enumValues__);
}

struct EnumSchema FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnumSchemaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *values() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfStrings(values()) &&
           verifier.EndTable();
  }
};

struct EnumSchemaBuilder {
  typedef EnumSchema Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> values) {
    fbb_.AddOffset(EnumSchema::VT_VALUES, values);
  }
  explicit EnumSchemaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnumSchema> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnumSchema>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EnumSchema> CreateEnumSchema(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> values = 0) {
  EnumSchemaBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EnumSchema> CreateEnumSchemaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*values) : 0;
  return mcp::CreateEnumSchema(
      _fbb,
      values__);
}

struct ProgressToken FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProgressTokenBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOKEN = 4
  };
  const ::flatbuffers::String *token() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TOKEN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOKEN) &&
           verifier.VerifyString(token()) &&
           verifier.EndTable();
  }
};

struct ProgressTokenBuilder {
  typedef ProgressToken Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_token(::flatbuffers::Offset<::flatbuffers::String> token) {
    fbb_.AddOffset(ProgressToken::VT_TOKEN, token);
  }
  explicit ProgressTokenBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ProgressToken> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ProgressToken>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ProgressToken> CreateProgressToken(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> token = 0) {
  ProgressTokenBuilder builder_(_fbb);
  builder_.add_token(token);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ProgressToken> CreateProgressTokenDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *token = nullptr) {
  auto token__ = token ? _fbb.CreateString(token) : 0;
  return mcp::CreateProgressToken(
      _fbb,
      token__);
}

struct RequestId FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestIdBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
};

struct RequestIdBuilder {
  typedef RequestId Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(RequestId::VT_ID, id);
  }
  explicit RequestIdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestId>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestId> CreateRequestId(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0) {
  RequestIdBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RequestId> CreateRequestIdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return mcp::CreateRequestId(
      _fbb,
      id__);
}

struct Cursor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CursorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FROM = 4,
    VT_TO = 6
  };
  uint32_t from() const {
    return GetField<uint32_t>(VT_FROM, 0);
  }
  uint32_t to() const {
    return GetField<uint32_t>(VT_TO, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FROM, 4) &&
           VerifyField<uint32_t>(verifier, VT_TO, 4) &&
           verifier.EndTable();
  }
};

struct CursorBuilder {
  typedef Cursor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_from(uint32_t from) {
    fbb_.AddElement<uint32_t>(Cursor::VT_FROM, from, 0);
  }
  void add_to(uint32_t to) {
    fbb_.AddElement<uint32_t>(Cursor::VT_TO, to, 0);
  }
  explicit CursorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Cursor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Cursor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Cursor> CreateCursor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t from = 0,
    uint32_t to = 0) {
  CursorBuilder builder_(_fbb);
  builder_.add_to(to);
  builder_.add_from(from);
  return builder_.Finish();
}

struct ModelHint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModelHintBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct ModelHintBuilder {
  typedef ModelHint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ModelHint::VT_NAME, name);
  }
  explicit ModelHintBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ModelHint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ModelHint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ModelHint> CreateModelHint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  ModelHintBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ModelHint> CreateModelHintDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return mcp::CreateModelHint(
      _fbb,
      name__);
}

struct ModelPreferences FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModelPreferencesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COSTPRIORITY = 4,
    VT_INTELLIGENCEPRIORITY = 6,
    VT_SPEEDPRIORITY = 8,
    VT_HINTS = 10
  };
  float costPriority() const {
    return GetField<float>(VT_COSTPRIORITY, 0.0f);
  }
  float intelligencePriority() const {
    return GetField<float>(VT_INTELLIGENCEPRIORITY, 0.0f);
  }
  float speedPriority() const {
    return GetField<float>(VT_SPEEDPRIORITY, 0.0f);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::ModelHint>> *hints() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::ModelHint>> *>(VT_HINTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_COSTPRIORITY, 4) &&
           VerifyField<float>(verifier, VT_INTELLIGENCEPRIORITY, 4) &&
           VerifyField<float>(verifier, VT_SPEEDPRIORITY, 4) &&
           VerifyOffset(verifier, VT_HINTS) &&
           verifier.VerifyVector(hints()) &&
           verifier.VerifyVectorOfTables(hints()) &&
           verifier.EndTable();
  }
};

struct ModelPreferencesBuilder {
  typedef ModelPreferences Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_costPriority(float costPriority) {
    fbb_.AddElement<float>(ModelPreferences::VT_COSTPRIORITY, costPriority, 0.0f);
  }
  void add_intelligencePriority(float intelligencePriority) {
    fbb_.AddElement<float>(ModelPreferences::VT_INTELLIGENCEPRIORITY, intelligencePriority, 0.0f);
  }
  void add_speedPriority(float speedPriority) {
    fbb_.AddElement<float>(ModelPreferences::VT_SPEEDPRIORITY, speedPriority, 0.0f);
  }
  void add_hints(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::ModelHint>>> hints) {
    fbb_.AddOffset(ModelPreferences::VT_HINTS, hints);
  }
  explicit ModelPreferencesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ModelPreferences> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ModelPreferences>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ModelPreferences> CreateModelPreferences(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float costPriority = 0.0f,
    float intelligencePriority = 0.0f,
    float speedPriority = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::ModelHint>>> hints = 0) {
  ModelPreferencesBuilder builder_(_fbb);
  builder_.add_hints(hints);
  builder_.add_speedPriority(speedPriority);
  builder_.add_intelligencePriority(intelligencePriority);
  builder_.add_costPriority(costPriority);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ModelPreferences> CreateModelPreferencesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float costPriority = 0.0f,
    float intelligencePriority = 0.0f,
    float speedPriority = 0.0f,
    const std::vector<::flatbuffers::Offset<mcp::ModelHint>> *hints = nullptr) {
  auto hints__ = hints ? _fbb.CreateVector<::flatbuffers::Offset<mcp::ModelHint>>(*hints) : 0;
  return mcp::CreateModelPreferences(
      _fbb,
      costPriority,
      intelligencePriority,
      speedPriority,
      hints__);
}

struct Result FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const ::flatbuffers::String *data() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           verifier.EndTable();
  }
};

struct ResultBuilder {
  typedef Result Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::String> data) {
    fbb_.AddOffset(Result::VT_DATA, data);
  }
  explicit ResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Result> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Result>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Result> CreateResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> data = 0) {
  ResultBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Result> CreateResultDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *data = nullptr) {
  auto data__ = data ? _fbb.CreateString(data) : 0;
  return mcp::CreateResult(
      _fbb,
      data__);
}

struct EmptyResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EmptyResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EMPTY = 4
  };
  bool empty() const {
    return GetField<uint8_t>(VT_EMPTY, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EMPTY, 1) &&
           verifier.EndTable();
  }
};

struct EmptyResultBuilder {
  typedef EmptyResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_empty(bool empty) {
    fbb_.AddElement<uint8_t>(EmptyResult::VT_EMPTY, static_cast<uint8_t>(empty), 0);
  }
  explicit EmptyResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EmptyResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EmptyResult>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EmptyResult> CreateEmptyResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool empty = false) {
  EmptyResultBuilder builder_(_fbb);
  builder_.add_empty(empty);
  return builder_.Finish();
}

struct JSONRPCError FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JSONRPCErrorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_MESSAGE = 6,
    VT_DATA = 8
  };
  int32_t code() const {
    return GetField<int32_t>(VT_CODE, 0);
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  const ::flatbuffers::String *data() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CODE, 4) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           verifier.EndTable();
  }
};

struct JSONRPCErrorBuilder {
  typedef JSONRPCError Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_code(int32_t code) {
    fbb_.AddElement<int32_t>(JSONRPCError::VT_CODE, code, 0);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(JSONRPCError::VT_MESSAGE, message);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::String> data) {
    fbb_.AddOffset(JSONRPCError::VT_DATA, data);
  }
  explicit JSONRPCErrorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JSONRPCError> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JSONRPCError>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JSONRPCError> CreateJSONRPCError(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t code = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0,
    ::flatbuffers::Offset<::flatbuffers::String> data = 0) {
  JSONRPCErrorBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_message(message);
  builder_.add_code(code);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<JSONRPCError> CreateJSONRPCErrorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t code = 0,
    const char *message = nullptr,
    const char *data = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  auto data__ = data ? _fbb.CreateString(data) : 0;
  return mcp::CreateJSONRPCError(
      _fbb,
      code,
      message__,
      data__);
}

struct JSONRPCRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JSONRPCRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_JSONRPC = 4,
    VT_ID = 6,
    VT_METHOD = 8,
    VT_PARAMS = 10
  };
  const ::flatbuffers::String *jsonrpc() const {
    return GetPointer<const ::flatbuffers::String *>(VT_JSONRPC);
  }
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *method() const {
    return GetPointer<const ::flatbuffers::String *>(VT_METHOD);
  }
  const ::flatbuffers::String *params() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARAMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_JSONRPC) &&
           verifier.VerifyString(jsonrpc()) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.VerifyString(method()) &&
           VerifyOffset(verifier, VT_PARAMS) &&
           verifier.VerifyString(params()) &&
           verifier.EndTable();
  }
};

struct JSONRPCRequestBuilder {
  typedef JSONRPCRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_jsonrpc(::flatbuffers::Offset<::flatbuffers::String> jsonrpc) {
    fbb_.AddOffset(JSONRPCRequest::VT_JSONRPC, jsonrpc);
  }
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(JSONRPCRequest::VT_ID, id);
  }
  void add_method(::flatbuffers::Offset<::flatbuffers::String> method) {
    fbb_.AddOffset(JSONRPCRequest::VT_METHOD, method);
  }
  void add_params(::flatbuffers::Offset<::flatbuffers::String> params) {
    fbb_.AddOffset(JSONRPCRequest::VT_PARAMS, params);
  }
  explicit JSONRPCRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JSONRPCRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JSONRPCRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JSONRPCRequest> CreateJSONRPCRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> jsonrpc = 0,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> method = 0,
    ::flatbuffers::Offset<::flatbuffers::String> params = 0) {
  JSONRPCRequestBuilder builder_(_fbb);
  builder_.add_params(params);
  builder_.add_method(method);
  builder_.add_id(id);
  builder_.add_jsonrpc(jsonrpc);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<JSONRPCRequest> CreateJSONRPCRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *jsonrpc = nullptr,
    const char *id = nullptr,
    const char *method = nullptr,
    const char *params = nullptr) {
  auto jsonrpc__ = jsonrpc ? _fbb.CreateString(jsonrpc) : 0;
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto method__ = method ? _fbb.CreateString(method) : 0;
  auto params__ = params ? _fbb.CreateString(params) : 0;
  return mcp::CreateJSONRPCRequest(
      _fbb,
      jsonrpc__,
      id__,
      method__,
      params__);
}

struct JSONRPCResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JSONRPCResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_JSONRPC = 4,
    VT_ID = 6,
    VT_RESULT = 8,
    VT_ERROR = 10
  };
  const ::flatbuffers::String *jsonrpc() const {
    return GetPointer<const ::flatbuffers::String *>(VT_JSONRPC);
  }
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  const mcp::JSONRPCError *error() const {
    return GetPointer<const mcp::JSONRPCError *>(VT_ERROR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_JSONRPC) &&
           verifier.VerifyString(jsonrpc()) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
};

struct JSONRPCResponseBuilder {
  typedef JSONRPCResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_jsonrpc(::flatbuffers::Offset<::flatbuffers::String> jsonrpc) {
    fbb_.AddOffset(JSONRPCResponse::VT_JSONRPC, jsonrpc);
  }
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(JSONRPCResponse::VT_ID, id);
  }
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(JSONRPCResponse::VT_RESULT, result);
  }
  void add_error(::flatbuffers::Offset<mcp::JSONRPCError> error) {
    fbb_.AddOffset(JSONRPCResponse::VT_ERROR, error);
  }
  explicit JSONRPCResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JSONRPCResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JSONRPCResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JSONRPCResponse> CreateJSONRPCResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> jsonrpc = 0,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    ::flatbuffers::Offset<mcp::JSONRPCError> error = 0) {
  JSONRPCResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_result(result);
  builder_.add_id(id);
  builder_.add_jsonrpc(jsonrpc);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<JSONRPCResponse> CreateJSONRPCResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *jsonrpc = nullptr,
    const char *id = nullptr,
    const char *result = nullptr,
    ::flatbuffers::Offset<mcp::JSONRPCError> error = 0) {
  auto jsonrpc__ = jsonrpc ? _fbb.CreateString(jsonrpc) : 0;
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto result__ = result ? _fbb.CreateString(result) : 0;
  return mcp::CreateJSONRPCResponse(
      _fbb,
      jsonrpc__,
      id__,
      result__,
      error);
}

struct JSONRPCNotification FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JSONRPCNotificationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_JSONRPC = 4,
    VT_METHOD = 6,
    VT_PARAMS = 8
  };
  const ::flatbuffers::String *jsonrpc() const {
    return GetPointer<const ::flatbuffers::String *>(VT_JSONRPC);
  }
  const ::flatbuffers::String *method() const {
    return GetPointer<const ::flatbuffers::String *>(VT_METHOD);
  }
  const ::flatbuffers::String *params() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARAMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_JSONRPC) &&
           verifier.VerifyString(jsonrpc()) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.VerifyString(method()) &&
           VerifyOffset(verifier, VT_PARAMS) &&
           verifier.VerifyString(params()) &&
           verifier.EndTable();
  }
};

struct JSONRPCNotificationBuilder {
  typedef JSONRPCNotification Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_jsonrpc(::flatbuffers::Offset<::flatbuffers::String> jsonrpc) {
    fbb_.AddOffset(JSONRPCNotification::VT_JSONRPC, jsonrpc);
  }
  void add_method(::flatbuffers::Offset<::flatbuffers::String> method) {
    fbb_.AddOffset(JSONRPCNotification::VT_METHOD, method);
  }
  void add_params(::flatbuffers::Offset<::flatbuffers::String> params) {
    fbb_.AddOffset(JSONRPCNotification::VT_PARAMS, params);
  }
  explicit JSONRPCNotificationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JSONRPCNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JSONRPCNotification>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JSONRPCNotification> CreateJSONRPCNotification(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> jsonrpc = 0,
    ::flatbuffers::Offset<::flatbuffers::String> method = 0,
    ::flatbuffers::Offset<::flatbuffers::String> params = 0) {
  JSONRPCNotificationBuilder builder_(_fbb);
  builder_.add_params(params);
  builder_.add_method(method);
  builder_.add_jsonrpc(jsonrpc);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<JSONRPCNotification> CreateJSONRPCNotificationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *jsonrpc = nullptr,
    const char *method = nullptr,
    const char *params = nullptr) {
  auto jsonrpc__ = jsonrpc ? _fbb.CreateString(jsonrpc) : 0;
  auto method__ = method ? _fbb.CreateString(method) : 0;
  auto params__ = params ? _fbb.CreateString(params) : 0;
  return mcp::CreateJSONRPCNotification(
      _fbb,
      jsonrpc__,
      method__,
      params__);
}

struct ContentBlock FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ContentBlockBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENT_TYPE = 4,
    VT_CONTENT = 6
  };
  mcp::Content content_type() const {
    return static_cast<mcp::Content>(GetField<uint8_t>(VT_CONTENT_TYPE, 0));
  }
  const void *content() const {
    return GetPointer<const void *>(VT_CONTENT);
  }
  template<typename T> const T *content_as() const;
  const mcp::TextContent *content_as_TextContent() const {
    return content_type() == mcp::Content_TextContent ? static_cast<const mcp::TextContent *>(content()) : nullptr;
  }
  const mcp::ImageContent *content_as_ImageContent() const {
    return content_type() == mcp::Content_ImageContent ? static_cast<const mcp::ImageContent *>(content()) : nullptr;
  }
  const mcp::AudioContent *content_as_AudioContent() const {
    return content_type() == mcp::Content_AudioContent ? static_cast<const mcp::AudioContent *>(content()) : nullptr;
  }
  const mcp::VideoContent *content_as_VideoContent() const {
    return content_type() == mcp::Content_VideoContent ? static_cast<const mcp::VideoContent *>(content()) : nullptr;
  }
  const mcp::BlobContent *content_as_BlobContent() const {
    return content_type() == mcp::Content_BlobContent ? static_cast<const mcp::BlobContent *>(content()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CONTENT_TYPE, 1) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           VerifyContent(verifier, content(), content_type()) &&
           verifier.EndTable();
  }
};

template<> inline const mcp::TextContent *ContentBlock::content_as<mcp::TextContent>() const {
  return content_as_TextContent();
}

template<> inline const mcp::ImageContent *ContentBlock::content_as<mcp::ImageContent>() const {
  return content_as_ImageContent();
}

template<> inline const mcp::AudioContent *ContentBlock::content_as<mcp::AudioContent>() const {
  return content_as_AudioContent();
}

template<> inline const mcp::VideoContent *ContentBlock::content_as<mcp::VideoContent>() const {
  return content_as_VideoContent();
}

template<> inline const mcp::BlobContent *ContentBlock::content_as<mcp::BlobContent>() const {
  return content_as_BlobContent();
}

struct ContentBlockBuilder {
  typedef ContentBlock Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_content_type(mcp::Content content_type) {
    fbb_.AddElement<uint8_t>(ContentBlock::VT_CONTENT_TYPE, static_cast<uint8_t>(content_type), 0);
  }
  void add_content(::flatbuffers::Offset<void> content) {
    fbb_.AddOffset(ContentBlock::VT_CONTENT, content);
  }
  explicit ContentBlockBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ContentBlock> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ContentBlock>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ContentBlock> CreateContentBlock(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    mcp::Content content_type = mcp::Content_NONE,
    ::flatbuffers::Offset<void> content = 0) {
  ContentBlockBuilder builder_(_fbb);
  builder_.add_content(content);
  builder_.add_content_type(content_type);
  return builder_.Finish();
}

struct PromptMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PromptMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROLE = 4,
    VT_CONTENT_TYPE = 6,
    VT_CONTENT = 8
  };
  mcp::Role role() const {
    return static_cast<mcp::Role>(GetField<int8_t>(VT_ROLE, 0));
  }
  const ::flatbuffers::Vector<uint8_t> *content_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CONTENT_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *content() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_CONTENT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ROLE, 1) &&
           VerifyOffset(verifier, VT_CONTENT_TYPE) &&
           verifier.VerifyVector(content_type()) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyVector(content()) &&
           VerifyContentVector(verifier, content(), content_type()) &&
           verifier.EndTable();
  }
};

struct PromptMessageBuilder {
  typedef PromptMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_role(mcp::Role role) {
    fbb_.AddElement<int8_t>(PromptMessage::VT_ROLE, static_cast<int8_t>(role), 0);
  }
  void add_content_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> content_type) {
    fbb_.AddOffset(PromptMessage::VT_CONTENT_TYPE, content_type);
  }
  void add_content(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> content) {
    fbb_.AddOffset(PromptMessage::VT_CONTENT, content);
  }
  explicit PromptMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PromptMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PromptMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PromptMessage> CreatePromptMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    mcp::Role role = mcp::Role_User,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> content_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> content = 0) {
  PromptMessageBuilder builder_(_fbb);
  builder_.add_content(content);
  builder_.add_content_type(content_type);
  builder_.add_role(role);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PromptMessage> CreatePromptMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    mcp::Role role = mcp::Role_User,
    const std::vector<uint8_t> *content_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *content = nullptr) {
  auto content_type__ = content_type ? _fbb.CreateVector<uint8_t>(*content_type) : 0;
  auto content__ = content ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*content) : 0;
  return mcp::CreatePromptMessage(
      _fbb,
      role,
      content_type__,
      content__);
}

struct SamplingMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SamplingMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROLE = 4,
    VT_CONTENT_TYPE = 6,
    VT_CONTENT = 8
  };
  mcp::Role role() const {
    return static_cast<mcp::Role>(GetField<int8_t>(VT_ROLE, 0));
  }
  const ::flatbuffers::Vector<uint8_t> *content_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CONTENT_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *content() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_CONTENT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ROLE, 1) &&
           VerifyOffset(verifier, VT_CONTENT_TYPE) &&
           verifier.VerifyVector(content_type()) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyVector(content()) &&
           VerifyContentVector(verifier, content(), content_type()) &&
           verifier.EndTable();
  }
};

struct SamplingMessageBuilder {
  typedef SamplingMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_role(mcp::Role role) {
    fbb_.AddElement<int8_t>(SamplingMessage::VT_ROLE, static_cast<int8_t>(role), 0);
  }
  void add_content_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> content_type) {
    fbb_.AddOffset(SamplingMessage::VT_CONTENT_TYPE, content_type);
  }
  void add_content(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> content) {
    fbb_.AddOffset(SamplingMessage::VT_CONTENT, content);
  }
  explicit SamplingMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SamplingMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SamplingMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SamplingMessage> CreateSamplingMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    mcp::Role role = mcp::Role_User,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> content_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> content = 0) {
  SamplingMessageBuilder builder_(_fbb);
  builder_.add_content(content);
  builder_.add_content_type(content_type);
  builder_.add_role(role);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SamplingMessage> CreateSamplingMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    mcp::Role role = mcp::Role_User,
    const std::vector<uint8_t> *content_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *content = nullptr) {
  auto content_type__ = content_type ? _fbb.CreateVector<uint8_t>(*content_type) : 0;
  auto content__ = content ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*content) : 0;
  return mcp::CreateSamplingMessage(
      _fbb,
      role,
      content_type__,
      content__);
}

struct PromptReference FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PromptReferenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct PromptReferenceBuilder {
  typedef PromptReference Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(PromptReference::VT_NAME, name);
  }
  explicit PromptReferenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PromptReference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PromptReference>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PromptReference> CreatePromptReference(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  PromptReferenceBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PromptReference> CreatePromptReferenceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return mcp::CreatePromptReference(
      _fbb,
      name__);
}

struct ResourceLink FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResourceLinkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_URI = 4,
    VT_NAME = 6
  };
  const ::flatbuffers::String *uri() const {
    return GetPointer<const ::flatbuffers::String *>(VT_URI);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_URI) &&
           verifier.VerifyString(uri()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct ResourceLinkBuilder {
  typedef ResourceLink Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uri(::flatbuffers::Offset<::flatbuffers::String> uri) {
    fbb_.AddOffset(ResourceLink::VT_URI, uri);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ResourceLink::VT_NAME, name);
  }
  explicit ResourceLinkBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResourceLink> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResourceLink>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResourceLink> CreateResourceLink(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> uri = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  ResourceLinkBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_uri(uri);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResourceLink> CreateResourceLinkDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *uri = nullptr,
    const char *name = nullptr) {
  auto uri__ = uri ? _fbb.CreateString(uri) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return mcp::CreateResourceLink(
      _fbb,
      uri__,
      name__);
}

struct EmbeddedResource FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EmbeddedResourceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_URI = 4,
    VT_NAME = 6,
    VT_MIMETYPE = 8
  };
  const ::flatbuffers::String *uri() const {
    return GetPointer<const ::flatbuffers::String *>(VT_URI);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *mimeType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MIMETYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_URI) &&
           verifier.VerifyString(uri()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_MIMETYPE) &&
           verifier.VerifyString(mimeType()) &&
           verifier.EndTable();
  }
};

struct EmbeddedResourceBuilder {
  typedef EmbeddedResource Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uri(::flatbuffers::Offset<::flatbuffers::String> uri) {
    fbb_.AddOffset(EmbeddedResource::VT_URI, uri);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(EmbeddedResource::VT_NAME, name);
  }
  void add_mimeType(::flatbuffers::Offset<::flatbuffers::String> mimeType) {
    fbb_.AddOffset(EmbeddedResource::VT_MIMETYPE, mimeType);
  }
  explicit EmbeddedResourceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EmbeddedResource> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EmbeddedResource>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EmbeddedResource> CreateEmbeddedResource(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> uri = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mimeType = 0) {
  EmbeddedResourceBuilder builder_(_fbb);
  builder_.add_mimeType(mimeType);
  builder_.add_name(name);
  builder_.add_uri(uri);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EmbeddedResource> CreateEmbeddedResourceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *uri = nullptr,
    const char *name = nullptr,
    const char *mimeType = nullptr) {
  auto uri__ = uri ? _fbb.CreateString(uri) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto mimeType__ = mimeType ? _fbb.CreateString(mimeType) : 0;
  return mcp::CreateEmbeddedResource(
      _fbb,
      uri__,
      name__,
      mimeType__);
}

struct ResourceTemplate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResourceTemplateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_URITEMPLATE = 4,
    VT_NAME = 6,
    VT_MIMETYPE = 8
  };
  const ::flatbuffers::String *uriTemplate() const {
    return GetPointer<const ::flatbuffers::String *>(VT_URITEMPLATE);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *mimeType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MIMETYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_URITEMPLATE) &&
           verifier.VerifyString(uriTemplate()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_MIMETYPE) &&
           verifier.VerifyString(mimeType()) &&
           verifier.EndTable();
  }
};

struct ResourceTemplateBuilder {
  typedef ResourceTemplate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uriTemplate(::flatbuffers::Offset<::flatbuffers::String> uriTemplate) {
    fbb_.AddOffset(ResourceTemplate::VT_URITEMPLATE, uriTemplate);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ResourceTemplate::VT_NAME, name);
  }
  void add_mimeType(::flatbuffers::Offset<::flatbuffers::String> mimeType) {
    fbb_.AddOffset(ResourceTemplate::VT_MIMETYPE, mimeType);
  }
  explicit ResourceTemplateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResourceTemplate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResourceTemplate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResourceTemplate> CreateResourceTemplate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> uriTemplate = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mimeType = 0) {
  ResourceTemplateBuilder builder_(_fbb);
  builder_.add_mimeType(mimeType);
  builder_.add_name(name);
  builder_.add_uriTemplate(uriTemplate);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResourceTemplate> CreateResourceTemplateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *uriTemplate = nullptr,
    const char *name = nullptr,
    const char *mimeType = nullptr) {
  auto uriTemplate__ = uriTemplate ? _fbb.CreateString(uriTemplate) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto mimeType__ = mimeType ? _fbb.CreateString(mimeType) : 0;
  return mcp::CreateResourceTemplate(
      _fbb,
      uriTemplate__,
      name__,
      mimeType__);
}

struct ResourceTemplateReference FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResourceTemplateReferenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_URITEMPLATE = 4
  };
  const ::flatbuffers::String *uriTemplate() const {
    return GetPointer<const ::flatbuffers::String *>(VT_URITEMPLATE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_URITEMPLATE) &&
           verifier.VerifyString(uriTemplate()) &&
           verifier.EndTable();
  }
};

struct ResourceTemplateReferenceBuilder {
  typedef ResourceTemplateReference Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uriTemplate(::flatbuffers::Offset<::flatbuffers::String> uriTemplate) {
    fbb_.AddOffset(ResourceTemplateReference::VT_URITEMPLATE, uriTemplate);
  }
  explicit ResourceTemplateReferenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResourceTemplateReference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResourceTemplateReference>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResourceTemplateReference> CreateResourceTemplateReference(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> uriTemplate = 0) {
  ResourceTemplateReferenceBuilder builder_(_fbb);
  builder_.add_uriTemplate(uriTemplate);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResourceTemplateReference> CreateResourceTemplateReferenceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *uriTemplate = nullptr) {
  auto uriTemplate__ = uriTemplate ? _fbb.CreateString(uriTemplate) : 0;
  return mcp::CreateResourceTemplateReference(
      _fbb,
      uriTemplate__);
}

struct TextResourceContents FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TextResourceContentsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_URI = 4,
    VT_MIMETYPE = 6,
    VT_TEXT = 8
  };
  const ::flatbuffers::String *uri() const {
    return GetPointer<const ::flatbuffers::String *>(VT_URI);
  }
  const ::flatbuffers::String *mimeType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MIMETYPE);
  }
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_URI) &&
           verifier.VerifyString(uri()) &&
           VerifyOffset(verifier, VT_MIMETYPE) &&
           verifier.VerifyString(mimeType()) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
};

struct TextResourceContentsBuilder {
  typedef TextResourceContents Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uri(::flatbuffers::Offset<::flatbuffers::String> uri) {
    fbb_.AddOffset(TextResourceContents::VT_URI, uri);
  }
  void add_mimeType(::flatbuffers::Offset<::flatbuffers::String> mimeType) {
    fbb_.AddOffset(TextResourceContents::VT_MIMETYPE, mimeType);
  }
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(TextResourceContents::VT_TEXT, text);
  }
  explicit TextResourceContentsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TextResourceContents> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TextResourceContents>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TextResourceContents> CreateTextResourceContents(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> uri = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mimeType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0) {
  TextResourceContentsBuilder builder_(_fbb);
  builder_.add_text(text);
  builder_.add_mimeType(mimeType);
  builder_.add_uri(uri);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TextResourceContents> CreateTextResourceContentsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *uri = nullptr,
    const char *mimeType = nullptr,
    const char *text = nullptr) {
  auto uri__ = uri ? _fbb.CreateString(uri) : 0;
  auto mimeType__ = mimeType ? _fbb.CreateString(mimeType) : 0;
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return mcp::CreateTextResourceContents(
      _fbb,
      uri__,
      mimeType__,
      text__);
}

struct ToolAnnotations FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ToolAnnotationsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANNOTATIONS = 4
  };
  const mcp::Annotations *annotations() const {
    return GetPointer<const mcp::Annotations *>(VT_ANNOTATIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ANNOTATIONS) &&
           verifier.VerifyTable(annotations()) &&
           verifier.EndTable();
  }
};

struct ToolAnnotationsBuilder {
  typedef ToolAnnotations Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_annotations(::flatbuffers::Offset<mcp::Annotations> annotations) {
    fbb_.AddOffset(ToolAnnotations::VT_ANNOTATIONS, annotations);
  }
  explicit ToolAnnotationsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ToolAnnotations> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ToolAnnotations>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ToolAnnotations> CreateToolAnnotations(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<mcp::Annotations> annotations = 0) {
  ToolAnnotationsBuilder builder_(_fbb);
  builder_.add_annotations(annotations);
  return builder_.Finish();
}

struct Implementation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ImplementationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VERSION = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           verifier.EndTable();
  }
};

struct ImplementationBuilder {
  typedef Implementation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Implementation::VT_NAME, name);
  }
  void add_version(::flatbuffers::Offset<::flatbuffers::String> version) {
    fbb_.AddOffset(Implementation::VT_VERSION, version);
  }
  explicit ImplementationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Implementation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Implementation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Implementation> CreateImplementation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> version = 0) {
  ImplementationBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Implementation> CreateImplementationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *version = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto version__ = version ? _fbb.CreateString(version) : 0;
  return mcp::CreateImplementation(
      _fbb,
      name__,
      version__);
}

struct CompleteRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CompleteRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_MESSAGES = 6,
    VT_PREFERENCES = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::SamplingMessage>> *messages() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::SamplingMessage>> *>(VT_MESSAGES);
  }
  const mcp::ModelPreferences *preferences() const {
    return GetPointer<const mcp::ModelPreferences *>(VT_PREFERENCES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_MESSAGES) &&
           verifier.VerifyVector(messages()) &&
           verifier.VerifyVectorOfTables(messages()) &&
           VerifyOffset(verifier, VT_PREFERENCES) &&
           verifier.VerifyTable(preferences()) &&
           verifier.EndTable();
  }
};

struct CompleteRequestBuilder {
  typedef CompleteRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(CompleteRequest::VT_ID, id);
  }
  void add_messages(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::SamplingMessage>>> messages) {
    fbb_.AddOffset(CompleteRequest::VT_MESSAGES, messages);
  }
  void add_preferences(::flatbuffers::Offset<mcp::ModelPreferences> preferences) {
    fbb_.AddOffset(CompleteRequest::VT_PREFERENCES, preferences);
  }
  explicit CompleteRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CompleteRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CompleteRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CompleteRequest> CreateCompleteRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::SamplingMessage>>> messages = 0,
    ::flatbuffers::Offset<mcp::ModelPreferences> preferences = 0) {
  CompleteRequestBuilder builder_(_fbb);
  builder_.add_preferences(preferences);
  builder_.add_messages(messages);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CompleteRequest> CreateCompleteRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const std::vector<::flatbuffers::Offset<mcp::SamplingMessage>> *messages = nullptr,
    ::flatbuffers::Offset<mcp::ModelPreferences> preferences = 0) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto messages__ = messages ? _fbb.CreateVector<::flatbuffers::Offset<mcp::SamplingMessage>>(*messages) : 0;
  return mcp::CreateCompleteRequest(
      _fbb,
      id__,
      messages__,
      preferences);
}

struct CompleteResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CompleteResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENT_TYPE = 4,
    VT_CONTENT = 6
  };
  const ::flatbuffers::Vector<uint8_t> *content_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CONTENT_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *content() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_CONTENT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTENT_TYPE) &&
           verifier.VerifyVector(content_type()) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyVector(content()) &&
           VerifyContentVector(verifier, content(), content_type()) &&
           verifier.EndTable();
  }
};

struct CompleteResultBuilder {
  typedef CompleteResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_content_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> content_type) {
    fbb_.AddOffset(CompleteResult::VT_CONTENT_TYPE, content_type);
  }
  void add_content(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> content) {
    fbb_.AddOffset(CompleteResult::VT_CONTENT, content);
  }
  explicit CompleteResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CompleteResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CompleteResult>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CompleteResult> CreateCompleteResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> content_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> content = 0) {
  CompleteResultBuilder builder_(_fbb);
  builder_.add_content(content);
  builder_.add_content_type(content_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CompleteResult> CreateCompleteResultDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *content_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *content = nullptr) {
  auto content_type__ = content_type ? _fbb.CreateVector<uint8_t>(*content_type) : 0;
  auto content__ = content ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*content) : 0;
  return mcp::CreateCompleteResult(
      _fbb,
      content_type__,
      content__);
}

struct ElicitRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ElicitRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CURSOR = 6
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const mcp::Cursor *cursor() const {
    return GetPointer<const mcp::Cursor *>(VT_CURSOR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CURSOR) &&
           verifier.VerifyTable(cursor()) &&
           verifier.EndTable();
  }
};

struct ElicitRequestBuilder {
  typedef ElicitRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(ElicitRequest::VT_ID, id);
  }
  void add_cursor(::flatbuffers::Offset<mcp::Cursor> cursor) {
    fbb_.AddOffset(ElicitRequest::VT_CURSOR, cursor);
  }
  explicit ElicitRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ElicitRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ElicitRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ElicitRequest> CreateElicitRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<mcp::Cursor> cursor = 0) {
  ElicitRequestBuilder builder_(_fbb);
  builder_.add_cursor(cursor);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ElicitRequest> CreateElicitRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    ::flatbuffers::Offset<mcp::Cursor> cursor = 0) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return mcp::CreateElicitRequest(
      _fbb,
      id__,
      cursor);
}

struct ElicitResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ElicitResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENT_TYPE = 4,
    VT_CONTENT = 6
  };
  const ::flatbuffers::Vector<uint8_t> *content_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CONTENT_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *content() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_CONTENT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTENT_TYPE) &&
           verifier.VerifyVector(content_type()) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyVector(content()) &&
           VerifyContentVector(verifier, content(), content_type()) &&
           verifier.EndTable();
  }
};

struct ElicitResultBuilder {
  typedef ElicitResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_content_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> content_type) {
    fbb_.AddOffset(ElicitResult::VT_CONTENT_TYPE, content_type);
  }
  void add_content(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> content) {
    fbb_.AddOffset(ElicitResult::VT_CONTENT, content);
  }
  explicit ElicitResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ElicitResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ElicitResult>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ElicitResult> CreateElicitResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> content_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> content = 0) {
  ElicitResultBuilder builder_(_fbb);
  builder_.add_content(content);
  builder_.add_content_type(content_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ElicitResult> CreateElicitResultDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *content_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *content = nullptr) {
  auto content_type__ = content_type ? _fbb.CreateVector<uint8_t>(*content_type) : 0;
  auto content__ = content ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*content) : 0;
  return mcp::CreateElicitResult(
      _fbb,
      content_type__,
      content__);
}

struct InitializeResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InitializeResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROTOCOLVERSION = 4,
    VT_CAPABILITIES = 6,
    VT_SERVERINFO = 8
  };
  const ::flatbuffers::String *protocolVersion() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROTOCOLVERSION);
  }
  const mcp::ServerCapabilities *capabilities() const {
    return GetPointer<const mcp::ServerCapabilities *>(VT_CAPABILITIES);
  }
  const ::flatbuffers::String *serverInfo() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SERVERINFO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROTOCOLVERSION) &&
           verifier.VerifyString(protocolVersion()) &&
           VerifyOffset(verifier, VT_CAPABILITIES) &&
           verifier.VerifyTable(capabilities()) &&
           VerifyOffset(verifier, VT_SERVERINFO) &&
           verifier.VerifyString(serverInfo()) &&
           verifier.EndTable();
  }
};

struct InitializeResultBuilder {
  typedef InitializeResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_protocolVersion(::flatbuffers::Offset<::flatbuffers::String> protocolVersion) {
    fbb_.AddOffset(InitializeResult::VT_PROTOCOLVERSION, protocolVersion);
  }
  void add_capabilities(::flatbuffers::Offset<mcp::ServerCapabilities> capabilities) {
    fbb_.AddOffset(InitializeResult::VT_CAPABILITIES, capabilities);
  }
  void add_serverInfo(::flatbuffers::Offset<::flatbuffers::String> serverInfo) {
    fbb_.AddOffset(InitializeResult::VT_SERVERINFO, serverInfo);
  }
  explicit InitializeResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InitializeResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InitializeResult>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InitializeResult> CreateInitializeResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> protocolVersion = 0,
    ::flatbuffers::Offset<mcp::ServerCapabilities> capabilities = 0,
    ::flatbuffers::Offset<::flatbuffers::String> serverInfo = 0) {
  InitializeResultBuilder builder_(_fbb);
  builder_.add_serverInfo(serverInfo);
  builder_.add_capabilities(capabilities);
  builder_.add_protocolVersion(protocolVersion);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<InitializeResult> CreateInitializeResultDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *protocolVersion = nullptr,
    ::flatbuffers::Offset<mcp::ServerCapabilities> capabilities = 0,
    const char *serverInfo = nullptr) {
  auto protocolVersion__ = protocolVersion ? _fbb.CreateString(protocolVersion) : 0;
  auto serverInfo__ = serverInfo ? _fbb.CreateString(serverInfo) : 0;
  return mcp::CreateInitializeResult(
      _fbb,
      protocolVersion__,
      capabilities,
      serverInfo__);
}

struct SetLevelRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetLevelRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEVEL = 4
  };
  mcp::LoggingLevel level() const {
    return static_cast<mcp::LoggingLevel>(GetField<int8_t>(VT_LEVEL, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_LEVEL, 1) &&
           verifier.EndTable();
  }
};

struct SetLevelRequestBuilder {
  typedef SetLevelRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_level(mcp::LoggingLevel level) {
    fbb_.AddElement<int8_t>(SetLevelRequest::VT_LEVEL, static_cast<int8_t>(level), 0);
  }
  explicit SetLevelRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetLevelRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetLevelRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetLevelRequest> CreateSetLevelRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    mcp::LoggingLevel level = mcp::LoggingLevel_DEBUG) {
  SetLevelRequestBuilder builder_(_fbb);
  builder_.add_level(level);
  return builder_.Finish();
}

struct PingRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PingRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
};

struct PingRequestBuilder {
  typedef PingRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(PingRequest::VT_ID, id);
  }
  explicit PingRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PingRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PingRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PingRequest> CreatePingRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0) {
  PingRequestBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PingRequest> CreatePingRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return mcp::CreatePingRequest(
      _fbb,
      id__);
}

struct GetPromptRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetPromptRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct GetPromptRequestBuilder {
  typedef GetPromptRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(GetPromptRequest::VT_NAME, name);
  }
  explicit GetPromptRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetPromptRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetPromptRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetPromptRequest> CreateGetPromptRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  GetPromptRequestBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GetPromptRequest> CreateGetPromptRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return mcp::CreateGetPromptRequest(
      _fbb,
      name__);
}

struct GetPromptResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetPromptResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROMPT = 4
  };
  const mcp::Prompt *prompt() const {
    return GetPointer<const mcp::Prompt *>(VT_PROMPT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROMPT) &&
           verifier.VerifyTable(prompt()) &&
           verifier.EndTable();
  }
};

struct GetPromptResultBuilder {
  typedef GetPromptResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_prompt(::flatbuffers::Offset<mcp::Prompt> prompt) {
    fbb_.AddOffset(GetPromptResult::VT_PROMPT, prompt);
  }
  explicit GetPromptResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetPromptResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetPromptResult>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetPromptResult> CreateGetPromptResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<mcp::Prompt> prompt = 0) {
  GetPromptResultBuilder builder_(_fbb);
  builder_.add_prompt(prompt);
  return builder_.Finish();
}

struct ListPromptsRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ListPromptsRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DUMMY = 4
  };
  bool dummy() const {
    return GetField<uint8_t>(VT_DUMMY, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DUMMY, 1) &&
           verifier.EndTable();
  }
};

struct ListPromptsRequestBuilder {
  typedef ListPromptsRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dummy(bool dummy) {
    fbb_.AddElement<uint8_t>(ListPromptsRequest::VT_DUMMY, static_cast<uint8_t>(dummy), 0);
  }
  explicit ListPromptsRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ListPromptsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ListPromptsRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ListPromptsRequest> CreateListPromptsRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool dummy = false) {
  ListPromptsRequestBuilder builder_(_fbb);
  builder_.add_dummy(dummy);
  return builder_.Finish();
}

struct ListPromptsResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ListPromptsResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROMPTS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::Prompt>> *prompts() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::Prompt>> *>(VT_PROMPTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROMPTS) &&
           verifier.VerifyVector(prompts()) &&
           verifier.VerifyVectorOfTables(prompts()) &&
           verifier.EndTable();
  }
};

struct ListPromptsResultBuilder {
  typedef ListPromptsResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_prompts(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::Prompt>>> prompts) {
    fbb_.AddOffset(ListPromptsResult::VT_PROMPTS, prompts);
  }
  explicit ListPromptsResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ListPromptsResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ListPromptsResult>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ListPromptsResult> CreateListPromptsResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::Prompt>>> prompts = 0) {
  ListPromptsResultBuilder builder_(_fbb);
  builder_.add_prompts(prompts);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ListPromptsResult> CreateListPromptsResultDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<mcp::Prompt>> *prompts = nullptr) {
  auto prompts__ = prompts ? _fbb.CreateVector<::flatbuffers::Offset<mcp::Prompt>>(*prompts) : 0;
  return mcp::CreateListPromptsResult(
      _fbb,
      prompts__);
}

struct ListResourcesRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ListResourcesRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DUMMY = 4
  };
  bool dummy() const {
    return GetField<uint8_t>(VT_DUMMY, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DUMMY, 1) &&
           verifier.EndTable();
  }
};

struct ListResourcesRequestBuilder {
  typedef ListResourcesRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dummy(bool dummy) {
    fbb_.AddElement<uint8_t>(ListResourcesRequest::VT_DUMMY, static_cast<uint8_t>(dummy), 0);
  }
  explicit ListResourcesRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ListResourcesRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ListResourcesRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ListResourcesRequest> CreateListResourcesRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool dummy = false) {
  ListResourcesRequestBuilder builder_(_fbb);
  builder_.add_dummy(dummy);
  return builder_.Finish();
}

struct ListResourcesResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ListResourcesResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESOURCES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::Resource>> *resources() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::Resource>> *>(VT_RESOURCES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RESOURCES) &&
           verifier.VerifyVector(resources()) &&
           verifier.VerifyVectorOfTables(resources()) &&
           verifier.EndTable();
  }
};

struct ListResourcesResultBuilder {
  typedef ListResourcesResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_resources(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::Resource>>> resources) {
    fbb_.AddOffset(ListResourcesResult::VT_RESOURCES, resources);
  }
  explicit ListResourcesResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ListResourcesResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ListResourcesResult>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ListResourcesResult> CreateListResourcesResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::Resource>>> resources = 0) {
  ListResourcesResultBuilder builder_(_fbb);
  builder_.add_resources(resources);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ListResourcesResult> CreateListResourcesResultDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<mcp::Resource>> *resources = nullptr) {
  auto resources__ = resources ? _fbb.CreateVector<::flatbuffers::Offset<mcp::Resource>>(*resources) : 0;
  return mcp::CreateListResourcesResult(
      _fbb,
      resources__);
}

struct ReadResourceRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReadResourceRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_URI = 4
  };
  const ::flatbuffers::String *uri() const {
    return GetPointer<const ::flatbuffers::String *>(VT_URI);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_URI) &&
           verifier.VerifyString(uri()) &&
           verifier.EndTable();
  }
};

struct ReadResourceRequestBuilder {
  typedef ReadResourceRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uri(::flatbuffers::Offset<::flatbuffers::String> uri) {
    fbb_.AddOffset(ReadResourceRequest::VT_URI, uri);
  }
  explicit ReadResourceRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReadResourceRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReadResourceRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReadResourceRequest> CreateReadResourceRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> uri = 0) {
  ReadResourceRequestBuilder builder_(_fbb);
  builder_.add_uri(uri);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ReadResourceRequest> CreateReadResourceRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *uri = nullptr) {
  auto uri__ = uri ? _fbb.CreateString(uri) : 0;
  return mcp::CreateReadResourceRequest(
      _fbb,
      uri__);
}

struct ReadResourceResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReadResourceResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENTS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::ResourceContents>> *contents() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::ResourceContents>> *>(VT_CONTENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTENTS) &&
           verifier.VerifyVector(contents()) &&
           verifier.VerifyVectorOfTables(contents()) &&
           verifier.EndTable();
  }
};

struct ReadResourceResultBuilder {
  typedef ReadResourceResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_contents(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::ResourceContents>>> contents) {
    fbb_.AddOffset(ReadResourceResult::VT_CONTENTS, contents);
  }
  explicit ReadResourceResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReadResourceResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReadResourceResult>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReadResourceResult> CreateReadResourceResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::ResourceContents>>> contents = 0) {
  ReadResourceResultBuilder builder_(_fbb);
  builder_.add_contents(contents);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ReadResourceResult> CreateReadResourceResultDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<mcp::ResourceContents>> *contents = nullptr) {
  auto contents__ = contents ? _fbb.CreateVector<::flatbuffers::Offset<mcp::ResourceContents>>(*contents) : 0;
  return mcp::CreateReadResourceResult(
      _fbb,
      contents__);
}

struct SubscribeRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SubscribeRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_URI = 4
  };
  const ::flatbuffers::String *uri() const {
    return GetPointer<const ::flatbuffers::String *>(VT_URI);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_URI) &&
           verifier.VerifyString(uri()) &&
           verifier.EndTable();
  }
};

struct SubscribeRequestBuilder {
  typedef SubscribeRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uri(::flatbuffers::Offset<::flatbuffers::String> uri) {
    fbb_.AddOffset(SubscribeRequest::VT_URI, uri);
  }
  explicit SubscribeRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SubscribeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SubscribeRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SubscribeRequest> CreateSubscribeRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> uri = 0) {
  SubscribeRequestBuilder builder_(_fbb);
  builder_.add_uri(uri);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SubscribeRequest> CreateSubscribeRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *uri = nullptr) {
  auto uri__ = uri ? _fbb.CreateString(uri) : 0;
  return mcp::CreateSubscribeRequest(
      _fbb,
      uri__);
}

struct ListResourceTemplatesRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ListResourceTemplatesRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DUMMY = 4
  };
  bool dummy() const {
    return GetField<uint8_t>(VT_DUMMY, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DUMMY, 1) &&
           verifier.EndTable();
  }
};

struct ListResourceTemplatesRequestBuilder {
  typedef ListResourceTemplatesRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dummy(bool dummy) {
    fbb_.AddElement<uint8_t>(ListResourceTemplatesRequest::VT_DUMMY, static_cast<uint8_t>(dummy), 0);
  }
  explicit ListResourceTemplatesRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ListResourceTemplatesRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ListResourceTemplatesRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ListResourceTemplatesRequest> CreateListResourceTemplatesRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool dummy = false) {
  ListResourceTemplatesRequestBuilder builder_(_fbb);
  builder_.add_dummy(dummy);
  return builder_.Finish();
}

struct ListResourceTemplatesResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ListResourceTemplatesResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEMPLATES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::ResourceTemplate>> *templates() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::ResourceTemplate>> *>(VT_TEMPLATES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEMPLATES) &&
           verifier.VerifyVector(templates()) &&
           verifier.VerifyVectorOfTables(templates()) &&
           verifier.EndTable();
  }
};

struct ListResourceTemplatesResultBuilder {
  typedef ListResourceTemplatesResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_templates(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::ResourceTemplate>>> templates) {
    fbb_.AddOffset(ListResourceTemplatesResult::VT_TEMPLATES, templates);
  }
  explicit ListResourceTemplatesResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ListResourceTemplatesResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ListResourceTemplatesResult>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ListResourceTemplatesResult> CreateListResourceTemplatesResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::ResourceTemplate>>> templates = 0) {
  ListResourceTemplatesResultBuilder builder_(_fbb);
  builder_.add_templates(templates);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ListResourceTemplatesResult> CreateListResourceTemplatesResultDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<mcp::ResourceTemplate>> *templates = nullptr) {
  auto templates__ = templates ? _fbb.CreateVector<::flatbuffers::Offset<mcp::ResourceTemplate>>(*templates) : 0;
  return mcp::CreateListResourceTemplatesResult(
      _fbb,
      templates__);
}

struct UnsubscribeRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UnsubscribeRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_URI = 4
  };
  const ::flatbuffers::String *uri() const {
    return GetPointer<const ::flatbuffers::String *>(VT_URI);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_URI) &&
           verifier.VerifyString(uri()) &&
           verifier.EndTable();
  }
};

struct UnsubscribeRequestBuilder {
  typedef UnsubscribeRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uri(::flatbuffers::Offset<::flatbuffers::String> uri) {
    fbb_.AddOffset(UnsubscribeRequest::VT_URI, uri);
  }
  explicit UnsubscribeRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UnsubscribeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UnsubscribeRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UnsubscribeRequest> CreateUnsubscribeRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> uri = 0) {
  UnsubscribeRequestBuilder builder_(_fbb);
  builder_.add_uri(uri);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UnsubscribeRequest> CreateUnsubscribeRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *uri = nullptr) {
  auto uri__ = uri ? _fbb.CreateString(uri) : 0;
  return mcp::CreateUnsubscribeRequest(
      _fbb,
      uri__);
}

struct RootEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RootEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_URI = 4,
    VT_NAME = 6
  };
  const ::flatbuffers::String *uri() const {
    return GetPointer<const ::flatbuffers::String *>(VT_URI);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_URI) &&
           verifier.VerifyString(uri()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct RootEntryBuilder {
  typedef RootEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uri(::flatbuffers::Offset<::flatbuffers::String> uri) {
    fbb_.AddOffset(RootEntry::VT_URI, uri);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(RootEntry::VT_NAME, name);
  }
  explicit RootEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RootEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RootEntry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RootEntry> CreateRootEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> uri = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  RootEntryBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_uri(uri);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RootEntry> CreateRootEntryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *uri = nullptr,
    const char *name = nullptr) {
  auto uri__ = uri ? _fbb.CreateString(uri) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return mcp::CreateRootEntry(
      _fbb,
      uri__,
      name__);
}

struct ListRootsRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ListRootsRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DUMMY = 4
  };
  bool dummy() const {
    return GetField<uint8_t>(VT_DUMMY, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DUMMY, 1) &&
           verifier.EndTable();
  }
};

struct ListRootsRequestBuilder {
  typedef ListRootsRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dummy(bool dummy) {
    fbb_.AddElement<uint8_t>(ListRootsRequest::VT_DUMMY, static_cast<uint8_t>(dummy), 0);
  }
  explicit ListRootsRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ListRootsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ListRootsRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ListRootsRequest> CreateListRootsRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool dummy = false) {
  ListRootsRequestBuilder builder_(_fbb);
  builder_.add_dummy(dummy);
  return builder_.Finish();
}

struct ListRootsResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ListRootsResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROOTS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::RootEntry>> *roots() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::RootEntry>> *>(VT_ROOTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROOTS) &&
           verifier.VerifyVector(roots()) &&
           verifier.VerifyVectorOfTables(roots()) &&
           verifier.EndTable();
  }
};

struct ListRootsResultBuilder {
  typedef ListRootsResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_roots(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::RootEntry>>> roots) {
    fbb_.AddOffset(ListRootsResult::VT_ROOTS, roots);
  }
  explicit ListRootsResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ListRootsResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ListRootsResult>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ListRootsResult> CreateListRootsResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::RootEntry>>> roots = 0) {
  ListRootsResultBuilder builder_(_fbb);
  builder_.add_roots(roots);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ListRootsResult> CreateListRootsResultDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<mcp::RootEntry>> *roots = nullptr) {
  auto roots__ = roots ? _fbb.CreateVector<::flatbuffers::Offset<mcp::RootEntry>>(*roots) : 0;
  return mcp::CreateListRootsResult(
      _fbb,
      roots__);
}

struct CreateMessageRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CreateMessageRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::SamplingMessage>> *messages() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::SamplingMessage>> *>(VT_MESSAGES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGES) &&
           verifier.VerifyVector(messages()) &&
           verifier.VerifyVectorOfTables(messages()) &&
           verifier.EndTable();
  }
};

struct CreateMessageRequestBuilder {
  typedef CreateMessageRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_messages(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::SamplingMessage>>> messages) {
    fbb_.AddOffset(CreateMessageRequest::VT_MESSAGES, messages);
  }
  explicit CreateMessageRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CreateMessageRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CreateMessageRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CreateMessageRequest> CreateCreateMessageRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::SamplingMessage>>> messages = 0) {
  CreateMessageRequestBuilder builder_(_fbb);
  builder_.add_messages(messages);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CreateMessageRequest> CreateCreateMessageRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<mcp::SamplingMessage>> *messages = nullptr) {
  auto messages__ = messages ? _fbb.CreateVector<::flatbuffers::Offset<mcp::SamplingMessage>>(*messages) : 0;
  return mcp::CreateCreateMessageRequest(
      _fbb,
      messages__);
}

struct CreateMessageResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CreateMessageResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE = 4
  };
  const mcp::SamplingMessage *message() const {
    return GetPointer<const mcp::SamplingMessage *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyTable(message()) &&
           verifier.EndTable();
  }
};

struct CreateMessageResultBuilder {
  typedef CreateMessageResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_message(::flatbuffers::Offset<mcp::SamplingMessage> message) {
    fbb_.AddOffset(CreateMessageResult::VT_MESSAGE, message);
  }
  explicit CreateMessageResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CreateMessageResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CreateMessageResult>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CreateMessageResult> CreateCreateMessageResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<mcp::SamplingMessage> message = 0) {
  CreateMessageResultBuilder builder_(_fbb);
  builder_.add_message(message);
  return builder_.Finish();
}

struct CallToolRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CallToolRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ARGUMENTS = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *arguments() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ARGUMENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_ARGUMENTS) &&
           verifier.VerifyString(arguments()) &&
           verifier.EndTable();
  }
};

struct CallToolRequestBuilder {
  typedef CallToolRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(CallToolRequest::VT_NAME, name);
  }
  void add_arguments(::flatbuffers::Offset<::flatbuffers::String> arguments) {
    fbb_.AddOffset(CallToolRequest::VT_ARGUMENTS, arguments);
  }
  explicit CallToolRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CallToolRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CallToolRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CallToolRequest> CreateCallToolRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> arguments = 0) {
  CallToolRequestBuilder builder_(_fbb);
  builder_.add_arguments(arguments);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CallToolRequest> CreateCallToolRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *arguments = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto arguments__ = arguments ? _fbb.CreateString(arguments) : 0;
  return mcp::CreateCallToolRequest(
      _fbb,
      name__,
      arguments__);
}

struct CallToolResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CallToolResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENT_TYPE = 4,
    VT_CONTENT = 6,
    VT_ISERROR = 8,
    VT_ERROR = 10
  };
  const ::flatbuffers::Vector<uint8_t> *content_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CONTENT_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *content() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_CONTENT);
  }
  bool isError() const {
    return GetField<uint8_t>(VT_ISERROR, 0) != 0;
  }
  const mcp::JSONRPCError *error() const {
    return GetPointer<const mcp::JSONRPCError *>(VT_ERROR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTENT_TYPE) &&
           verifier.VerifyVector(content_type()) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyVector(content()) &&
           VerifyContentVector(verifier, content(), content_type()) &&
           VerifyField<uint8_t>(verifier, VT_ISERROR, 1) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
};

struct CallToolResultBuilder {
  typedef CallToolResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_content_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> content_type) {
    fbb_.AddOffset(CallToolResult::VT_CONTENT_TYPE, content_type);
  }
  void add_content(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> content) {
    fbb_.AddOffset(CallToolResult::VT_CONTENT, content);
  }
  void add_isError(bool isError) {
    fbb_.AddElement<uint8_t>(CallToolResult::VT_ISERROR, static_cast<uint8_t>(isError), 0);
  }
  void add_error(::flatbuffers::Offset<mcp::JSONRPCError> error) {
    fbb_.AddOffset(CallToolResult::VT_ERROR, error);
  }
  explicit CallToolResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CallToolResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CallToolResult>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CallToolResult> CreateCallToolResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> content_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> content = 0,
    bool isError = false,
    ::flatbuffers::Offset<mcp::JSONRPCError> error = 0) {
  CallToolResultBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_content(content);
  builder_.add_content_type(content_type);
  builder_.add_isError(isError);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CallToolResult> CreateCallToolResultDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *content_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *content = nullptr,
    bool isError = false,
    ::flatbuffers::Offset<mcp::JSONRPCError> error = 0) {
  auto content_type__ = content_type ? _fbb.CreateVector<uint8_t>(*content_type) : 0;
  auto content__ = content ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*content) : 0;
  return mcp::CreateCallToolResult(
      _fbb,
      content_type__,
      content__,
      isError,
      error);
}

struct ListToolsRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ListToolsRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DUMMY = 4
  };
  bool dummy() const {
    return GetField<uint8_t>(VT_DUMMY, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DUMMY, 1) &&
           verifier.EndTable();
  }
};

struct ListToolsRequestBuilder {
  typedef ListToolsRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dummy(bool dummy) {
    fbb_.AddElement<uint8_t>(ListToolsRequest::VT_DUMMY, static_cast<uint8_t>(dummy), 0);
  }
  explicit ListToolsRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ListToolsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ListToolsRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ListToolsRequest> CreateListToolsRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool dummy = false) {
  ListToolsRequestBuilder builder_(_fbb);
  builder_.add_dummy(dummy);
  return builder_.Finish();
}

struct ListToolsResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ListToolsResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOOLS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::Tool>> *tools() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<mcp::Tool>> *>(VT_TOOLS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOOLS) &&
           verifier.VerifyVector(tools()) &&
           verifier.VerifyVectorOfTables(tools()) &&
           verifier.EndTable();
  }
};

struct ListToolsResultBuilder {
  typedef ListToolsResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tools(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::Tool>>> tools) {
    fbb_.AddOffset(ListToolsResult::VT_TOOLS, tools);
  }
  explicit ListToolsResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ListToolsResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ListToolsResult>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ListToolsResult> CreateListToolsResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mcp::Tool>>> tools = 0) {
  ListToolsResultBuilder builder_(_fbb);
  builder_.add_tools(tools);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ListToolsResult> CreateListToolsResultDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<mcp::Tool>> *tools = nullptr) {
  auto tools__ = tools ? _fbb.CreateVector<::flatbuffers::Offset<mcp::Tool>>(*tools) : 0;
  return mcp::CreateListToolsResult(
      _fbb,
      tools__);
}

struct CancelledNotification FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CancelledNotificationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROGRESSTOKEN = 4
  };
  const ::flatbuffers::String *progressToken() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROGRESSTOKEN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROGRESSTOKEN) &&
           verifier.VerifyString(progressToken()) &&
           verifier.EndTable();
  }
};

struct CancelledNotificationBuilder {
  typedef CancelledNotification Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_progressToken(::flatbuffers::Offset<::flatbuffers::String> progressToken) {
    fbb_.AddOffset(CancelledNotification::VT_PROGRESSTOKEN, progressToken);
  }
  explicit CancelledNotificationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CancelledNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CancelledNotification>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CancelledNotification> CreateCancelledNotification(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> progressToken = 0) {
  CancelledNotificationBuilder builder_(_fbb);
  builder_.add_progressToken(progressToken);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CancelledNotification> CreateCancelledNotificationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *progressToken = nullptr) {
  auto progressToken__ = progressToken ? _fbb.CreateString(progressToken) : 0;
  return mcp::CreateCancelledNotification(
      _fbb,
      progressToken__);
}

struct InitializedNotification FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InitializedNotificationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DUMMY = 4
  };
  bool dummy() const {
    return GetField<uint8_t>(VT_DUMMY, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DUMMY, 1) &&
           verifier.EndTable();
  }
};

struct InitializedNotificationBuilder {
  typedef InitializedNotification Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dummy(bool dummy) {
    fbb_.AddElement<uint8_t>(InitializedNotification::VT_DUMMY, static_cast<uint8_t>(dummy), 0);
  }
  explicit InitializedNotificationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InitializedNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InitializedNotification>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InitializedNotification> CreateInitializedNotification(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool dummy = false) {
  InitializedNotificationBuilder builder_(_fbb);
  builder_.add_dummy(dummy);
  return builder_.Finish();
}

struct LoggingMessageNotification FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LoggingMessageNotificationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEVEL = 4,
    VT_MESSAGE = 6
  };
  mcp::LoggingLevel level() const {
    return static_cast<mcp::LoggingLevel>(GetField<int8_t>(VT_LEVEL, 0));
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_LEVEL, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct LoggingMessageNotificationBuilder {
  typedef LoggingMessageNotification Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_level(mcp::LoggingLevel level) {
    fbb_.AddElement<int8_t>(LoggingMessageNotification::VT_LEVEL, static_cast<int8_t>(level), 0);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(LoggingMessageNotification::VT_MESSAGE, message);
  }
  explicit LoggingMessageNotificationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LoggingMessageNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LoggingMessageNotification>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LoggingMessageNotification> CreateLoggingMessageNotification(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    mcp::LoggingLevel level = mcp::LoggingLevel_DEBUG,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  LoggingMessageNotificationBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_level(level);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LoggingMessageNotification> CreateLoggingMessageNotificationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    mcp::LoggingLevel level = mcp::LoggingLevel_DEBUG,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return mcp::CreateLoggingMessageNotification(
      _fbb,
      level,
      message__);
}

struct ProgressNotification FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProgressNotificationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROGRESSTOKEN = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *progressToken() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROGRESSTOKEN);
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROGRESSTOKEN) &&
           verifier.VerifyString(progressToken()) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct ProgressNotificationBuilder {
  typedef ProgressNotification Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_progressToken(::flatbuffers::Offset<::flatbuffers::String> progressToken) {
    fbb_.AddOffset(ProgressNotification::VT_PROGRESSTOKEN, progressToken);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(ProgressNotification::VT_VALUE, value, 0.0f);
  }
  explicit ProgressNotificationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ProgressNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ProgressNotification>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ProgressNotification> CreateProgressNotification(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> progressToken = 0,
    float value = 0.0f) {
  ProgressNotificationBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_progressToken(progressToken);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ProgressNotification> CreateProgressNotificationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *progressToken = nullptr,
    float value = 0.0f) {
  auto progressToken__ = progressToken ? _fbb.CreateString(progressToken) : 0;
  return mcp::CreateProgressNotification(
      _fbb,
      progressToken__,
      value);
}

struct PromptListChangedNotification FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PromptListChangedNotificationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DUMMY = 4
  };
  bool dummy() const {
    return GetField<uint8_t>(VT_DUMMY, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DUMMY, 1) &&
           verifier.EndTable();
  }
};

struct PromptListChangedNotificationBuilder {
  typedef PromptListChangedNotification Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dummy(bool dummy) {
    fbb_.AddElement<uint8_t>(PromptListChangedNotification::VT_DUMMY, static_cast<uint8_t>(dummy), 0);
  }
  explicit PromptListChangedNotificationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PromptListChangedNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PromptListChangedNotification>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PromptListChangedNotification> CreatePromptListChangedNotification(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool dummy = false) {
  PromptListChangedNotificationBuilder builder_(_fbb);
  builder_.add_dummy(dummy);
  return builder_.Finish();
}

struct ResourceListChangedNotification FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResourceListChangedNotificationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DUMMY = 4
  };
  bool dummy() const {
    return GetField<uint8_t>(VT_DUMMY, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DUMMY, 1) &&
           verifier.EndTable();
  }
};

struct ResourceListChangedNotificationBuilder {
  typedef ResourceListChangedNotification Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dummy(bool dummy) {
    fbb_.AddElement<uint8_t>(ResourceListChangedNotification::VT_DUMMY, static_cast<uint8_t>(dummy), 0);
  }
  explicit ResourceListChangedNotificationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResourceListChangedNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResourceListChangedNotification>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResourceListChangedNotification> CreateResourceListChangedNotification(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool dummy = false) {
  ResourceListChangedNotificationBuilder builder_(_fbb);
  builder_.add_dummy(dummy);
  return builder_.Finish();
}

struct ResourceUpdatedNotification FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResourceUpdatedNotificationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_URI = 4
  };
  const ::flatbuffers::String *uri() const {
    return GetPointer<const ::flatbuffers::String *>(VT_URI);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_URI) &&
           verifier.VerifyString(uri()) &&
           verifier.EndTable();
  }
};

struct ResourceUpdatedNotificationBuilder {
  typedef ResourceUpdatedNotification Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uri(::flatbuffers::Offset<::flatbuffers::String> uri) {
    fbb_.AddOffset(ResourceUpdatedNotification::VT_URI, uri);
  }
  explicit ResourceUpdatedNotificationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResourceUpdatedNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResourceUpdatedNotification>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResourceUpdatedNotification> CreateResourceUpdatedNotification(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> uri = 0) {
  ResourceUpdatedNotificationBuilder builder_(_fbb);
  builder_.add_uri(uri);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResourceUpdatedNotification> CreateResourceUpdatedNotificationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *uri = nullptr) {
  auto uri__ = uri ? _fbb.CreateString(uri) : 0;
  return mcp::CreateResourceUpdatedNotification(
      _fbb,
      uri__);
}

struct RootsListChangedNotification FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RootsListChangedNotificationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DUMMY = 4
  };
  bool dummy() const {
    return GetField<uint8_t>(VT_DUMMY, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DUMMY, 1) &&
           verifier.EndTable();
  }
};

struct RootsListChangedNotificationBuilder {
  typedef RootsListChangedNotification Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dummy(bool dummy) {
    fbb_.AddElement<uint8_t>(RootsListChangedNotification::VT_DUMMY, static_cast<uint8_t>(dummy), 0);
  }
  explicit RootsListChangedNotificationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RootsListChangedNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RootsListChangedNotification>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RootsListChangedNotification> CreateRootsListChangedNotification(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool dummy = false) {
  RootsListChangedNotificationBuilder builder_(_fbb);
  builder_.add_dummy(dummy);
  return builder_.Finish();
}

struct ToolListChangedNotification FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ToolListChangedNotificationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DUMMY = 4
  };
  bool dummy() const {
    return GetField<uint8_t>(VT_DUMMY, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DUMMY, 1) &&
           verifier.EndTable();
  }
};

struct ToolListChangedNotificationBuilder {
  typedef ToolListChangedNotification Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dummy(bool dummy) {
    fbb_.AddElement<uint8_t>(ToolListChangedNotification::VT_DUMMY, static_cast<uint8_t>(dummy), 0);
  }
  explicit ToolListChangedNotificationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ToolListChangedNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ToolListChangedNotification>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ToolListChangedNotification> CreateToolListChangedNotification(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool dummy = false) {
  ToolListChangedNotificationBuilder builder_(_fbb);
  builder_.add_dummy(dummy);
  return builder_.Finish();
}

struct Root FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RootBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  mcp::RootMessage message_type() const {
    return static_cast<mcp::RootMessage>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const mcp::JSONRPCRequest *message_as_JSONRPCRequest() const {
    return message_type() == mcp::RootMessage_JSONRPCRequest ? static_cast<const mcp::JSONRPCRequest *>(message()) : nullptr;
  }
  const mcp::JSONRPCResponse *message_as_JSONRPCResponse() const {
    return message_type() == mcp::RootMessage_JSONRPCResponse ? static_cast<const mcp::JSONRPCResponse *>(message()) : nullptr;
  }
  const mcp::JSONRPCNotification *message_as_JSONRPCNotification() const {
    return message_type() == mcp::RootMessage_JSONRPCNotification ? static_cast<const mcp::JSONRPCNotification *>(message()) : nullptr;
  }
  const mcp::InitializeRequest *message_as_InitializeRequest() const {
    return message_type() == mcp::RootMessage_InitializeRequest ? static_cast<const mcp::InitializeRequest *>(message()) : nullptr;
  }
  const mcp::InitializeResponse *message_as_InitializeResponse() const {
    return message_type() == mcp::RootMessage_InitializeResponse ? static_cast<const mcp::InitializeResponse *>(message()) : nullptr;
  }
  const mcp::InitializeResult *message_as_InitializeResult() const {
    return message_type() == mcp::RootMessage_InitializeResult ? static_cast<const mcp::InitializeResult *>(message()) : nullptr;
  }
  const mcp::Ping *message_as_Ping() const {
    return message_type() == mcp::RootMessage_Ping ? static_cast<const mcp::Ping *>(message()) : nullptr;
  }
  const mcp::Pong *message_as_Pong() const {
    return message_type() == mcp::RootMessage_Pong ? static_cast<const mcp::Pong *>(message()) : nullptr;
  }
  const mcp::PingRequest *message_as_PingRequest() const {
    return message_type() == mcp::RootMessage_PingRequest ? static_cast<const mcp::PingRequest *>(message()) : nullptr;
  }
  const mcp::CompleteRequest *message_as_CompleteRequest() const {
    return message_type() == mcp::RootMessage_CompleteRequest ? static_cast<const mcp::CompleteRequest *>(message()) : nullptr;
  }
  const mcp::CompleteResult *message_as_CompleteResult() const {
    return message_type() == mcp::RootMessage_CompleteResult ? static_cast<const mcp::CompleteResult *>(message()) : nullptr;
  }
  const mcp::ElicitRequest *message_as_ElicitRequest() const {
    return message_type() == mcp::RootMessage_ElicitRequest ? static_cast<const mcp::ElicitRequest *>(message()) : nullptr;
  }
  const mcp::ElicitResult *message_as_ElicitResult() const {
    return message_type() == mcp::RootMessage_ElicitResult ? static_cast<const mcp::ElicitResult *>(message()) : nullptr;
  }
  const mcp::GetPromptRequest *message_as_GetPromptRequest() const {
    return message_type() == mcp::RootMessage_GetPromptRequest ? static_cast<const mcp::GetPromptRequest *>(message()) : nullptr;
  }
  const mcp::GetPromptResult *message_as_GetPromptResult() const {
    return message_type() == mcp::RootMessage_GetPromptResult ? static_cast<const mcp::GetPromptResult *>(message()) : nullptr;
  }
  const mcp::ListPromptsRequest *message_as_ListPromptsRequest() const {
    return message_type() == mcp::RootMessage_ListPromptsRequest ? static_cast<const mcp::ListPromptsRequest *>(message()) : nullptr;
  }
  const mcp::ListPromptsResult *message_as_ListPromptsResult() const {
    return message_type() == mcp::RootMessage_ListPromptsResult ? static_cast<const mcp::ListPromptsResult *>(message()) : nullptr;
  }
  const mcp::ListResourcesRequest *message_as_ListResourcesRequest() const {
    return message_type() == mcp::RootMessage_ListResourcesRequest ? static_cast<const mcp::ListResourcesRequest *>(message()) : nullptr;
  }
  const mcp::ListResourcesResult *message_as_ListResourcesResult() const {
    return message_type() == mcp::RootMessage_ListResourcesResult ? static_cast<const mcp::ListResourcesResult *>(message()) : nullptr;
  }
  const mcp::ReadResourceRequest *message_as_ReadResourceRequest() const {
    return message_type() == mcp::RootMessage_ReadResourceRequest ? static_cast<const mcp::ReadResourceRequest *>(message()) : nullptr;
  }
  const mcp::ReadResourceResult *message_as_ReadResourceResult() const {
    return message_type() == mcp::RootMessage_ReadResourceResult ? static_cast<const mcp::ReadResourceResult *>(message()) : nullptr;
  }
  const mcp::SubscribeRequest *message_as_SubscribeRequest() const {
    return message_type() == mcp::RootMessage_SubscribeRequest ? static_cast<const mcp::SubscribeRequest *>(message()) : nullptr;
  }
  const mcp::UnsubscribeRequest *message_as_UnsubscribeRequest() const {
    return message_type() == mcp::RootMessage_UnsubscribeRequest ? static_cast<const mcp::UnsubscribeRequest *>(message()) : nullptr;
  }
  const mcp::ListResourceTemplatesRequest *message_as_ListResourceTemplatesRequest() const {
    return message_type() == mcp::RootMessage_ListResourceTemplatesRequest ? static_cast<const mcp::ListResourceTemplatesRequest *>(message()) : nullptr;
  }
  const mcp::ListResourceTemplatesResult *message_as_ListResourceTemplatesResult() const {
    return message_type() == mcp::RootMessage_ListResourceTemplatesResult ? static_cast<const mcp::ListResourceTemplatesResult *>(message()) : nullptr;
  }
  const mcp::ResourceUpdatedNotification *message_as_ResourceUpdatedNotification() const {
    return message_type() == mcp::RootMessage_ResourceUpdatedNotification ? static_cast<const mcp::ResourceUpdatedNotification *>(message()) : nullptr;
  }
  const mcp::ListRootsRequest *message_as_ListRootsRequest() const {
    return message_type() == mcp::RootMessage_ListRootsRequest ? static_cast<const mcp::ListRootsRequest *>(message()) : nullptr;
  }
  const mcp::ListRootsResult *message_as_ListRootsResult() const {
    return message_type() == mcp::RootMessage_ListRootsResult ? static_cast<const mcp::ListRootsResult *>(message()) : nullptr;
  }
  const mcp::CreateMessageRequest *message_as_CreateMessageRequest() const {
    return message_type() == mcp::RootMessage_CreateMessageRequest ? static_cast<const mcp::CreateMessageRequest *>(message()) : nullptr;
  }
  const mcp::CreateMessageResult *message_as_CreateMessageResult() const {
    return message_type() == mcp::RootMessage_CreateMessageResult ? static_cast<const mcp::CreateMessageResult *>(message()) : nullptr;
  }
  const mcp::CallToolRequest *message_as_CallToolRequest() const {
    return message_type() == mcp::RootMessage_CallToolRequest ? static_cast<const mcp::CallToolRequest *>(message()) : nullptr;
  }
  const mcp::CallToolResult *message_as_CallToolResult() const {
    return message_type() == mcp::RootMessage_CallToolResult ? static_cast<const mcp::CallToolResult *>(message()) : nullptr;
  }
  const mcp::ListToolsRequest *message_as_ListToolsRequest() const {
    return message_type() == mcp::RootMessage_ListToolsRequest ? static_cast<const mcp::ListToolsRequest *>(message()) : nullptr;
  }
  const mcp::ListToolsResult *message_as_ListToolsResult() const {
    return message_type() == mcp::RootMessage_ListToolsResult ? static_cast<const mcp::ListToolsResult *>(message()) : nullptr;
  }
  const mcp::ToolListChangedNotification *message_as_ToolListChangedNotification() const {
    return message_type() == mcp::RootMessage_ToolListChangedNotification ? static_cast<const mcp::ToolListChangedNotification *>(message()) : nullptr;
  }
  const mcp::SetLevelRequest *message_as_SetLevelRequest() const {
    return message_type() == mcp::RootMessage_SetLevelRequest ? static_cast<const mcp::SetLevelRequest *>(message()) : nullptr;
  }
  const mcp::LoggingMessageNotification *message_as_LoggingMessageNotification() const {
    return message_type() == mcp::RootMessage_LoggingMessageNotification ? static_cast<const mcp::LoggingMessageNotification *>(message()) : nullptr;
  }
  const mcp::CancelledNotification *message_as_CancelledNotification() const {
    return message_type() == mcp::RootMessage_CancelledNotification ? static_cast<const mcp::CancelledNotification *>(message()) : nullptr;
  }
  const mcp::InitializedNotification *message_as_InitializedNotification() const {
    return message_type() == mcp::RootMessage_InitializedNotification ? static_cast<const mcp::InitializedNotification *>(message()) : nullptr;
  }
  const mcp::ProgressNotification *message_as_ProgressNotification() const {
    return message_type() == mcp::RootMessage_ProgressNotification ? static_cast<const mcp::ProgressNotification *>(message()) : nullptr;
  }
  const mcp::PromptListChangedNotification *message_as_PromptListChangedNotification() const {
    return message_type() == mcp::RootMessage_PromptListChangedNotification ? static_cast<const mcp::PromptListChangedNotification *>(message()) : nullptr;
  }
  const mcp::ResourceListChangedNotification *message_as_ResourceListChangedNotification() const {
    return message_type() == mcp::RootMessage_ResourceListChangedNotification ? static_cast<const mcp::ResourceListChangedNotification *>(message()) : nullptr;
  }
  const mcp::RootsListChangedNotification *message_as_RootsListChangedNotification() const {
    return message_type() == mcp::RootMessage_RootsListChangedNotification ? static_cast<const mcp::RootsListChangedNotification *>(message()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyRootMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const mcp::JSONRPCRequest *Root::message_as<mcp::JSONRPCRequest>() const {
  return message_as_JSONRPCRequest();
}

template<> inline const mcp::JSONRPCResponse *Root::message_as<mcp::JSONRPCResponse>() const {
  return message_as_JSONRPCResponse();
}

template<> inline const mcp::JSONRPCNotification *Root::message_as<mcp::JSONRPCNotification>() const {
  return message_as_JSONRPCNotification();
}

template<> inline const mcp::InitializeRequest *Root::message_as<mcp::InitializeRequest>() const {
  return message_as_InitializeRequest();
}

template<> inline const mcp::InitializeResponse *Root::message_as<mcp::InitializeResponse>() const {
  return message_as_InitializeResponse();
}

template<> inline const mcp::InitializeResult *Root::message_as<mcp::InitializeResult>() const {
  return message_as_InitializeResult();
}

template<> inline const mcp::Ping *Root::message_as<mcp::Ping>() const {
  return message_as_Ping();
}

template<> inline const mcp::Pong *Root::message_as<mcp::Pong>() const {
  return message_as_Pong();
}

template<> inline const mcp::PingRequest *Root::message_as<mcp::PingRequest>() const {
  return message_as_PingRequest();
}

template<> inline const mcp::CompleteRequest *Root::message_as<mcp::CompleteRequest>() const {
  return message_as_CompleteRequest();
}

template<> inline const mcp::CompleteResult *Root::message_as<mcp::CompleteResult>() const {
  return message_as_CompleteResult();
}

template<> inline const mcp::ElicitRequest *Root::message_as<mcp::ElicitRequest>() const {
  return message_as_ElicitRequest();
}

template<> inline const mcp::ElicitResult *Root::message_as<mcp::ElicitResult>() const {
  return message_as_ElicitResult();
}

template<> inline const mcp::GetPromptRequest *Root::message_as<mcp::GetPromptRequest>() const {
  return message_as_GetPromptRequest();
}

template<> inline const mcp::GetPromptResult *Root::message_as<mcp::GetPromptResult>() const {
  return message_as_GetPromptResult();
}

template<> inline const mcp::ListPromptsRequest *Root::message_as<mcp::ListPromptsRequest>() const {
  return message_as_ListPromptsRequest();
}

template<> inline const mcp::ListPromptsResult *Root::message_as<mcp::ListPromptsResult>() const {
  return message_as_ListPromptsResult();
}

template<> inline const mcp::ListResourcesRequest *Root::message_as<mcp::ListResourcesRequest>() const {
  return message_as_ListResourcesRequest();
}

template<> inline const mcp::ListResourcesResult *Root::message_as<mcp::ListResourcesResult>() const {
  return message_as_ListResourcesResult();
}

template<> inline const mcp::ReadResourceRequest *Root::message_as<mcp::ReadResourceRequest>() const {
  return message_as_ReadResourceRequest();
}

template<> inline const mcp::ReadResourceResult *Root::message_as<mcp::ReadResourceResult>() const {
  return message_as_ReadResourceResult();
}

template<> inline const mcp::SubscribeRequest *Root::message_as<mcp::SubscribeRequest>() const {
  return message_as_SubscribeRequest();
}

template<> inline const mcp::UnsubscribeRequest *Root::message_as<mcp::UnsubscribeRequest>() const {
  return message_as_UnsubscribeRequest();
}

template<> inline const mcp::ListResourceTemplatesRequest *Root::message_as<mcp::ListResourceTemplatesRequest>() const {
  return message_as_ListResourceTemplatesRequest();
}

template<> inline const mcp::ListResourceTemplatesResult *Root::message_as<mcp::ListResourceTemplatesResult>() const {
  return message_as_ListResourceTemplatesResult();
}

template<> inline const mcp::ResourceUpdatedNotification *Root::message_as<mcp::ResourceUpdatedNotification>() const {
  return message_as_ResourceUpdatedNotification();
}

template<> inline const mcp::ListRootsRequest *Root::message_as<mcp::ListRootsRequest>() const {
  return message_as_ListRootsRequest();
}

template<> inline const mcp::ListRootsResult *Root::message_as<mcp::ListRootsResult>() const {
  return message_as_ListRootsResult();
}

template<> inline const mcp::CreateMessageRequest *Root::message_as<mcp::CreateMessageRequest>() const {
  return message_as_CreateMessageRequest();
}

template<> inline const mcp::CreateMessageResult *Root::message_as<mcp::CreateMessageResult>() const {
  return message_as_CreateMessageResult();
}

template<> inline const mcp::CallToolRequest *Root::message_as<mcp::CallToolRequest>() const {
  return message_as_CallToolRequest();
}

template<> inline const mcp::CallToolResult *Root::message_as<mcp::CallToolResult>() const {
  return message_as_CallToolResult();
}

template<> inline const mcp::ListToolsRequest *Root::message_as<mcp::ListToolsRequest>() const {
  return message_as_ListToolsRequest();
}

template<> inline const mcp::ListToolsResult *Root::message_as<mcp::ListToolsResult>() const {
  return message_as_ListToolsResult();
}

template<> inline const mcp::ToolListChangedNotification *Root::message_as<mcp::ToolListChangedNotification>() const {
  return message_as_ToolListChangedNotification();
}

template<> inline const mcp::SetLevelRequest *Root::message_as<mcp::SetLevelRequest>() const {
  return message_as_SetLevelRequest();
}

template<> inline const mcp::LoggingMessageNotification *Root::message_as<mcp::LoggingMessageNotification>() const {
  return message_as_LoggingMessageNotification();
}

template<> inline const mcp::CancelledNotification *Root::message_as<mcp::CancelledNotification>() const {
  return message_as_CancelledNotification();
}

template<> inline const mcp::InitializedNotification *Root::message_as<mcp::InitializedNotification>() const {
  return message_as_InitializedNotification();
}

template<> inline const mcp::ProgressNotification *Root::message_as<mcp::ProgressNotification>() const {
  return message_as_ProgressNotification();
}

template<> inline const mcp::PromptListChangedNotification *Root::message_as<mcp::PromptListChangedNotification>() const {
  return message_as_PromptListChangedNotification();
}

template<> inline const mcp::ResourceListChangedNotification *Root::message_as<mcp::ResourceListChangedNotification>() const {
  return message_as_ResourceListChangedNotification();
}

template<> inline const mcp::RootsListChangedNotification *Root::message_as<mcp::RootsListChangedNotification>() const {
  return message_as_RootsListChangedNotification();
}

struct RootBuilder {
  typedef Root Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_message_type(mcp::RootMessage message_type) {
    fbb_.AddElement<uint8_t>(Root::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(::flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Root::VT_MESSAGE, message);
  }
  explicit RootBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Root> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Root>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Root> CreateRoot(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    mcp::RootMessage message_type = mcp::RootMessage_NONE,
    ::flatbuffers::Offset<void> message = 0) {
  RootBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline bool VerifyMessage(::flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_Request: {
      auto ptr = reinterpret_cast<const mcp::Request *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Response: {
      auto ptr = reinterpret_cast<const mcp::Response *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Notification: {
      auto ptr = reinterpret_cast<const mcp::Notification *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(
        verifier,  values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyContent(::flatbuffers::Verifier &verifier, const void *obj, Content type) {
  switch (type) {
    case Content_NONE: {
      return true;
    }
    case Content_TextContent: {
      auto ptr = reinterpret_cast<const mcp::TextContent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Content_ImageContent: {
      auto ptr = reinterpret_cast<const mcp::ImageContent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Content_AudioContent: {
      auto ptr = reinterpret_cast<const mcp::AudioContent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Content_VideoContent: {
      auto ptr = reinterpret_cast<const mcp::VideoContent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Content_BlobContent: {
      auto ptr = reinterpret_cast<const mcp::BlobContent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyContentVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyContent(
        verifier,  values->Get(i), types->GetEnum<Content>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyRootMessage(::flatbuffers::Verifier &verifier, const void *obj, RootMessage type) {
  switch (type) {
    case RootMessage_NONE: {
      return true;
    }
    case RootMessage_JSONRPCRequest: {
      auto ptr = reinterpret_cast<const mcp::JSONRPCRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_JSONRPCResponse: {
      auto ptr = reinterpret_cast<const mcp::JSONRPCResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_JSONRPCNotification: {
      auto ptr = reinterpret_cast<const mcp::JSONRPCNotification *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_InitializeRequest: {
      auto ptr = reinterpret_cast<const mcp::InitializeRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_InitializeResponse: {
      auto ptr = reinterpret_cast<const mcp::InitializeResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_InitializeResult: {
      auto ptr = reinterpret_cast<const mcp::InitializeResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_Ping: {
      auto ptr = reinterpret_cast<const mcp::Ping *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_Pong: {
      auto ptr = reinterpret_cast<const mcp::Pong *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_PingRequest: {
      auto ptr = reinterpret_cast<const mcp::PingRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_CompleteRequest: {
      auto ptr = reinterpret_cast<const mcp::CompleteRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_CompleteResult: {
      auto ptr = reinterpret_cast<const mcp::CompleteResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_ElicitRequest: {
      auto ptr = reinterpret_cast<const mcp::ElicitRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_ElicitResult: {
      auto ptr = reinterpret_cast<const mcp::ElicitResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_GetPromptRequest: {
      auto ptr = reinterpret_cast<const mcp::GetPromptRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_GetPromptResult: {
      auto ptr = reinterpret_cast<const mcp::GetPromptResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_ListPromptsRequest: {
      auto ptr = reinterpret_cast<const mcp::ListPromptsRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_ListPromptsResult: {
      auto ptr = reinterpret_cast<const mcp::ListPromptsResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_ListResourcesRequest: {
      auto ptr = reinterpret_cast<const mcp::ListResourcesRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_ListResourcesResult: {
      auto ptr = reinterpret_cast<const mcp::ListResourcesResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_ReadResourceRequest: {
      auto ptr = reinterpret_cast<const mcp::ReadResourceRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_ReadResourceResult: {
      auto ptr = reinterpret_cast<const mcp::ReadResourceResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_SubscribeRequest: {
      auto ptr = reinterpret_cast<const mcp::SubscribeRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_UnsubscribeRequest: {
      auto ptr = reinterpret_cast<const mcp::UnsubscribeRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_ListResourceTemplatesRequest: {
      auto ptr = reinterpret_cast<const mcp::ListResourceTemplatesRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_ListResourceTemplatesResult: {
      auto ptr = reinterpret_cast<const mcp::ListResourceTemplatesResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_ResourceUpdatedNotification: {
      auto ptr = reinterpret_cast<const mcp::ResourceUpdatedNotification *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_ListRootsRequest: {
      auto ptr = reinterpret_cast<const mcp::ListRootsRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_ListRootsResult: {
      auto ptr = reinterpret_cast<const mcp::ListRootsResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_CreateMessageRequest: {
      auto ptr = reinterpret_cast<const mcp::CreateMessageRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_CreateMessageResult: {
      auto ptr = reinterpret_cast<const mcp::CreateMessageResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_CallToolRequest: {
      auto ptr = reinterpret_cast<const mcp::CallToolRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_CallToolResult: {
      auto ptr = reinterpret_cast<const mcp::CallToolResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_ListToolsRequest: {
      auto ptr = reinterpret_cast<const mcp::ListToolsRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_ListToolsResult: {
      auto ptr = reinterpret_cast<const mcp::ListToolsResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_ToolListChangedNotification: {
      auto ptr = reinterpret_cast<const mcp::ToolListChangedNotification *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_SetLevelRequest: {
      auto ptr = reinterpret_cast<const mcp::SetLevelRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_LoggingMessageNotification: {
      auto ptr = reinterpret_cast<const mcp::LoggingMessageNotification *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_CancelledNotification: {
      auto ptr = reinterpret_cast<const mcp::CancelledNotification *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_InitializedNotification: {
      auto ptr = reinterpret_cast<const mcp::InitializedNotification *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_ProgressNotification: {
      auto ptr = reinterpret_cast<const mcp::ProgressNotification *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_PromptListChangedNotification: {
      auto ptr = reinterpret_cast<const mcp::PromptListChangedNotification *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_ResourceListChangedNotification: {
      auto ptr = reinterpret_cast<const mcp::ResourceListChangedNotification *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RootMessage_RootsListChangedNotification: {
      auto ptr = reinterpret_cast<const mcp::RootsListChangedNotification *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRootMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRootMessage(
        verifier,  values->Get(i), types->GetEnum<RootMessage>(i))) {
      return false;
    }
  }
  return true;
}

inline const mcp::Root *GetRoot(const void *buf) {
  return ::flatbuffers::GetRoot<mcp::Root>(buf);
}

inline const mcp::Root *GetSizePrefixedRoot(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<mcp::Root>(buf);
}

inline bool VerifyRootBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<mcp::Root>(nullptr);
}

inline bool VerifySizePrefixedRootBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<mcp::Root>(nullptr);
}

inline void FinishRootBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<mcp::Root> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRootBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<mcp::Root> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace mcp

#endif  // FLATBUFFERS_GENERATED_MCP_MCP_H_
